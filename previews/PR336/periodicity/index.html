<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fixed points &amp; Periodicity · ChaosTools.jl</title><meta name="title" content="Fixed points &amp; Periodicity · ChaosTools.jl"/><meta property="og:title" content="Fixed points &amp; Periodicity · ChaosTools.jl"/><meta property="twitter:title" content="Fixed points &amp; Periodicity · ChaosTools.jl"/><meta name="description" content="Documentation for ChaosTools.jl."/><meta property="og:description" content="Documentation for ChaosTools.jl."/><meta property="twitter:description" content="Documentation for ChaosTools.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ChaosTools.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">ChaosTools.jl</a></li><li><a class="tocitem" href="../orbitdiagram/">Orbit diagrams</a></li><li><a class="tocitem" href="../lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="../chaos_detection/">Detecting &amp; Categorizing Chaos</a></li><li><a class="tocitem" href="../dimreduction/">Dimensionality reduction</a></li><li class="is-active"><a class="tocitem" href>Fixed points &amp; Periodicity</a><ul class="internal"><li><a class="tocitem" href="#Fixed-points"><span>Fixed points</span></a></li><li><a class="tocitem" href="#Stable-and-Unstable-Periodic-Orbits-of-Maps"><span>Stable and Unstable Periodic Orbits of Maps</span></a></li><li><a class="tocitem" href="#Estimating-the-Period"><span>Estimating the Period</span></a></li></ul></li><li><a class="tocitem" href="../rareevents/">Rare events</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Fixed points &amp; Periodicity</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fixed points &amp; Periodicity</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/ChaosTools.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/main/docs/src/periodicity.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Fixed-points-and-Periodicity"><a class="docs-heading-anchor" href="#Fixed-points-and-Periodicity">Fixed points &amp; Periodicity</a><a id="Fixed-points-and-Periodicity-1"></a><a class="docs-heading-anchor-permalink" href="#Fixed-points-and-Periodicity" title="Permalink"></a></h1><h2 id="Fixed-points"><a class="docs-heading-anchor" href="#Fixed-points">Fixed points</a><a id="Fixed-points-1"></a><a class="docs-heading-anchor-permalink" href="#Fixed-points" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChaosTools.fixedpoints" href="#ChaosTools.fixedpoints"><code>ChaosTools.fixedpoints</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fixedpoints(ds::CoreDynamicalSystem, box, J = nothing; kwargs...) → fp, eigs, stable</code></pre><p>Return all fixed points <code>fp</code> of the given out-of-place <code>ds</code> (either <code>DeterministicIteratedMap</code> or <code>CoupledODEs</code>) that exist within the state space subset <code>box</code> for parameter configuration <code>p</code>. Fixed points are returned as a <a href="@ref"><code>StateSpaceSet</code></a>. For convenience, a vector of the Jacobian eigenvalues of each fixed point, and whether the fixed points are stable or not, are also returned.</p><p><code>box</code> is an appropriate <code>IntervalBox</code> from IntervalRootFinding.jl. E.g. for a 3D system it would be something like</p><pre><code class="language-julia hljs">v, z = -5..5, -2..2   # 1D intervals, can use `interval(-5, 5)` instead
box = v × v × z       # `\times = ×`, or use `IntervalBox(v, v, z)` instead</code></pre><p><code>J</code> is the Jacobian of the dynamic rule of <code>ds</code>. It is like in <a href="../#DynamicalSystemsBase.TangentDynamicalSystem"><code>TangentDynamicalSystem</code></a>, however in this case automatic Jacobian estimation does not work, hence a hand-coded version must be given.</p><p>Internally IntervalRootFinding.jl is used and as a result we are guaranteed to find all fixed points that exist in <code>box</code>, regardless of stability. Since IntervalRootFinding.jl returns an interval containing a unique fixed point, we return the midpoint of the interval as the actual fixed point. Naturally, limitations inherent to IntervalRootFinding.jl apply here.</p><p>The output of <code>fixedpoints</code> can be used in the <a href="https://github.com/rveltz/BifurcationKit.jl">BifurcationKit.jl</a> as a start of a continuation process. See also <a href="#ChaosTools.periodicorbits"><code>periodicorbits</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>method = IntervalRootFinding.Krawczyk</code> configures the root finding method, see the docs of IntervalRootFinding.jl for all possibilities.</li><li><code>tol = 1e-15</code> is the root-finding tolerance.</li><li><code>warn = true</code> throw a warning if no fixed points are found.</li><li><code>order = nothing</code> search for fixed points of the n-th iterate of  <a href="../#DynamicalSystemsBase.DeterministicIteratedMap"><code>DeterministicIteratedMap</code></a>. Must be a positive integer or <code>nothing</code>. Select <code>nothing</code> or 1 to search for the fixed points of the original map.</li></ul><p><strong>Performance notes</strong></p><p>Setting <code>order</code> to a value greater than 5 can be very slow. Consider using  more suitable algorithms for periodic orbit detection, such as  <a href="#ChaosTools.periodicorbits"><code>periodicorbits</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/5476f7189a2463c787efac71c75bddd9cdce8531/src/stability/fixedpoints.jl#L5-L50">source</a></section></article><p>A rather simple example of the fixed points can be demonstrated using E.g., the Lorenz-63 system, whose fixed points can be calculated analytically to be the following three</p><p class="math-container">\[(0,0,0) \\
\left( \sqrt{\beta(\rho-1)}, \sqrt{\beta(\rho-1)}, \rho-1 \right) \\
\left( -\sqrt{\beta(\rho-1)}, -\sqrt{\beta(\rho-1)}, \rho-1 \right) \\\]</p><p>So, let&#39;s calculate</p><pre><code class="language-julia hljs">using ChaosTools

function lorenz_rule(u, p, t)
    σ = p[1]; ρ = p[2]; β = p[3]
    du1 = σ*(u[2]-u[1])
    du2 = u[1]*(ρ-u[3]) - u[2]
    du3 = u[1]*u[2] - β*u[3]
    return SVector{3}(du1, du2, du3)
end
function lorenz_jacob(u, p, t)
    σ, ρ, β = p
    return SMatrix{3,3}(-σ, ρ - u[3], u[2], σ, -1, u[1], 0, -u[1], -β)
end

ρ, β = 30.0, 10/3
lorenz = CoupledODEs(lorenz_rule, 10ones(3), [10.0, ρ, β])
# Define the box within which to find fixed points:
x = y = interval(-20, 20)
z = interval(0, 40)
box = x × y × z

fp, eigs, stable = fixedpoints(lorenz, box, lorenz_jacob)
fp</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-dimensional StateSpaceSet{Float64} with 3 points
  9.83192       9.83192      29.0
 -9.83192      -9.83192      29.0
  3.23647e-17   3.23647e-17   3.43473e-16</code></pre><p>and compare this with the analytic ones:</p><pre><code class="language-julia hljs">lorenzfp(ρ, β) = [
    SVector(0, 0, 0.0),
    SVector(sqrt(β*(ρ-1)), sqrt(β*(ρ-1)), ρ-1),
    SVector(-sqrt(β*(ρ-1)), -sqrt(β*(ρ-1)), ρ-1),
]

lorenzfp(ρ, β)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{SVector{3, Float64}}:
 [0.0, 0.0, 0.0]
 [9.83192080250175, 9.83192080250175, 29.0]
 [-9.83192080250175, -9.83192080250175, 29.0]</code></pre><h2 id="Stable-and-Unstable-Periodic-Orbits-of-Maps"><a class="docs-heading-anchor" href="#Stable-and-Unstable-Periodic-Orbits-of-Maps">Stable and Unstable Periodic Orbits of Maps</a><a id="Stable-and-Unstable-Periodic-Orbits-of-Maps-1"></a><a class="docs-heading-anchor-permalink" href="#Stable-and-Unstable-Periodic-Orbits-of-Maps" title="Permalink"></a></h2><p>Chaotic behavior of low dimensional dynamical systems is affected by the position and the stability properties of the <a href="http://www.scholarpedia.org/article/Unstable_periodic_orbits">periodic orbits</a> of a dynamical system.</p><p>Finding unstable (or stable) periodic orbits of a discrete mapping analytically rapidly becomes impossible for higher orders of fixed points. Fortunately there are numerical algorithms that allow their detection.</p><h3 id="Schmelcher-and-Diakonos"><a class="docs-heading-anchor" href="#Schmelcher-and-Diakonos">Schmelcher &amp; Diakonos</a><a id="Schmelcher-and-Diakonos-1"></a><a class="docs-heading-anchor-permalink" href="#Schmelcher-and-Diakonos" title="Permalink"></a></h3><p>First of the algorithms was proposed by Schmelcher &amp; Diakonos (<a href="../references/#Schmelcher1997">Schmelcher and Diakonos, 1997</a>). Notice that even though the algorithm can find stable fixed points, it is mainly  aimed at <em>unstable</em> ones.</p><p>The functions <code>periodicorbits</code> and <code>lambdamatrix</code> implement the algorithm:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChaosTools.periodicorbits" href="#ChaosTools.periodicorbits"><code>ChaosTools.periodicorbits</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">periodicorbits(ds::DeterministicIteratedMap,
               o, ics [, λs, indss, singss]; kwargs...) -&gt; FP</code></pre><p>Find fixed points <code>FP</code> of order <code>o</code> for the map <code>ds</code> using the algorithm due to Schmelcher &amp; Diakonos<sup class="footnote-reference"><a id="citeref-Schmelcher1997" href="#footnote-Schmelcher1997">[Schmelcher1997]</a></sup>. <code>ics</code> is a collection of initial conditions (container of vectors) to be evolved.</p><p><strong>Optional arguments</strong></p><p>The optional arguments <code>λs, indss, singss</code> <em>must be containers</em> of appropriate values, besides <code>λs</code> which can also be a number. The elements of those containers are passed to: <a href="#ChaosTools.lambdamatrix"><code>lambdamatrix(λ, inds, sings)</code></a>, which creates the appropriate <span>$\mathbf{\Lambda}_k$</span> matrix. If these arguments are not given, a random permutation will be chosen for them, with <code>λ=0.001</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>maxiters::Int = 100000</code>: Maximum amount of iterations an i.c. will be iterated  before claiming it has not converged.</li><li><code>disttol = 1e-10</code>: Distance tolerance. If the 2-norm of a previous state with  the next one is <code>≤ disttol</code> then it has converged to a fixed point.</li><li><code>inftol = 10.0</code>: If a state reaches <code>norm(state) ≥ inftol</code> it is assumed that  it has escaped to infinity (and is thus abandoned).</li><li><code>abstol = 1e-8</code>: A detected fixed point isn&#39;t stored if it is in <code>abstol</code>  neighborhood of some previously detected point. Distance is measured by  euclidian norm. If you are getting duplicate fixed points, decrease this value.</li></ul><p><strong>Description</strong></p><p>The algorithm used can detect periodic orbits by turning fixed points of the original map <code>ds</code> to stable ones, through the transformation</p><p class="math-container">\[\mathbf{x}_{n+1} = \mathbf{x}_n +
\mathbf{\Lambda}_k\left(f^{(o)}(\mathbf{x}_n) - \mathbf{x}_n\right)\]</p><p>The index <span>$k$</span> counts the various possible <span>$\mathbf{\Lambda}_k$</span>.</p><p><strong>Performance notes</strong></p><p><em>All</em> initial conditions are evolved for <em>all</em> <span>$\mathbf{\Lambda}_k$</span> which can very quickly lead to long computation times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/5476f7189a2463c787efac71c75bddd9cdce8531/src/periodicity/periodicorbits.jl#L9-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChaosTools.lambdamatrix" href="#ChaosTools.lambdamatrix"><code>ChaosTools.lambdamatrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lambdamatrix(λ, inds::Vector{Int}, sings) -&gt; Λk</code></pre><p>Return the matrix <span>$\mathbf{\Lambda}_k$</span> used to create a new dynamical system with some unstable fixed points turned to stable in the function <a href="#ChaosTools.periodicorbits"><code>periodicorbits</code></a>.</p><p><strong>Arguments</strong></p><ol><li><code>λ&lt;:Real</code> : the multiplier of the <span>$C_k$</span> matrix, with <code>0&lt;λ&lt;1</code>.</li><li><code>inds::Vector{Int}</code> : The <code>i</code>th entry of this vector gives the <em>row</em> of the nonzero element of the <code>i</code>th column of <span>$C_k$</span>.</li><li><code>sings::Vector{&lt;:Real}</code> : The element of the <code>i</code>th column of <span>$C_k$</span> is +1 if <code>signs[i] &gt; 0</code> and -1 otherwise (<code>sings</code> can also be <code>Bool</code> vector).</li></ol><p>Calling <code>lambdamatrix(λ, D::Int)</code> creates a random <span>$\mathbf{\Lambda}_k$</span> by randomly generating an <code>inds</code> and a <code>signs</code> from all possible combinations. The <em>collections</em> of all these combinations can be obtained from the function <a href="#ChaosTools.lambdaperms"><code>lambdaperms</code></a>.</p><p><strong>Description</strong></p><p>Each element of <code>inds</code> <em>must be unique</em> such that the resulting matrix is orthogonal and represents the group of special reflections and permutations.</p><p>Deciding the appropriate values for <code>λ, inds, sings</code> is not trivial. However, in ref.<sup class="footnote-reference"><a id="citeref-Pingel2000" href="#footnote-Pingel2000">[Pingel2000]</a></sup> there is a lot of information that can help with that decision. Also, by appropriately choosing various values for <code>λ</code>, one can sort periodic orbits from e.g. least unstable to most unstable, see<sup class="footnote-reference"><a id="citeref-Diakonos1998" href="#footnote-Diakonos1998">[Diakonos1998]</a></sup> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/5476f7189a2463c787efac71c75bddd9cdce8531/src/periodicity/lambdamatrix.jl#L6-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChaosTools.lambdaperms" href="#ChaosTools.lambdaperms"><code>ChaosTools.lambdaperms</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lambdaperms(D) -&gt; indperms, singperms</code></pre><p>Return two collections that each contain all possible combinations of indices (total of <span>$D!$</span>) and signs (total of <span>$2^D$</span>) for dimension <code>D</code> (see <a href="#ChaosTools.lambdamatrix"><code>lambdamatrix</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/5476f7189a2463c787efac71c75bddd9cdce8531/src/periodicity/lambdamatrix.jl#L54-L59">source</a></section></article><h4 id="Standard-Map-example"><a class="docs-heading-anchor" href="#Standard-Map-example">Standard Map example</a><a id="Standard-Map-example-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-Map-example" title="Permalink"></a></h4><p>For example, let&#39;s find the fixed points of the Standard map of order 2, 3, 4, 5, 6 and 8. We will use all permutations for the <code>signs</code> but only one for the <code>inds</code>. We will also only use one <code>λ</code> value, and a 21×21 density of initial conditions.</p><p>First, initialize everything</p><pre><code class="language- hljs">using ChaosTools

function standardmap_rule(x, k, n)
    theta = x[1]; p = x[2]
    p += k[1]*sin(theta)
    theta += p
    return SVector(mod2pi(theta), mod2pi(p))
end

standardmap = DeterministicIteratedMap(standardmap_rule, rand(2), [1.0])
xs = range(0, stop = 2π, length = 11); ys = copy(xs)
ics = [SVector{2}(x,y) for x in xs for y in ys]

# All permutations of [±1, ±1]:
singss = lambdaperms(2)[2] # second entry are the signs

# I know from personal research I only need this `inds`:
indss = [[1,2]] # &lt;- must be container of vectors!

λs = 0.005 # &lt;- only this allowed to not be vector (could also be vector)

orders = [2, 3, 4, 5, 6, 8]
ALLFP = Dataset{2, Float64}[]

standardmap</code></pre><p>Then, do the necessary computations for all orders</p><pre><code class="language- hljs">for o in orders
    FP = periodicorbits(standardmap, o, ics, λs, indss, singss)
    push!(ALLFP, FP)
end</code></pre><p>Plot the phase space of the standard map</p><pre><code class="language-julia hljs">using CairoMakie
iters = 1000
dataset = trajectory(standardmap, iters)[1]
for x in xs
    for y in ys
        append!(dataset, trajectory(standardmap, iters, [x, y])[1])
    end
end

fig = Figure()
ax = Axis(fig[1,1]; xlabel = L&quot;\theta&quot;, ylabel = L&quot;p&quot;,
    limits = ((xs[1],xs[end]), (xs[1],xs[end]))
)
scatter!(ax, dataset[:, 1], dataset[:, 2]; markersize = 1, color = &quot;black&quot;)
fig</code></pre><img src="43859467.png" alt="Example block output"/><p>and finally, plot the fixed points</p><pre><code class="language- hljs">markers = [:diamond, :utriangle, :rect, :pentagon, :hexagon, :circle]

for i in 1:6
    FP = ALLFP[i]
    o = orders[i]
    scatter!(ax, columns(FP)...; marker=markers[i], color = Cycled(i),
        markersize = 30 - 2i, strokecolor = &quot;grey&quot;, strokewidth = 1, label = &quot;order $o&quot;
    )
end
axislegend(ax)
fig</code></pre><p>Okay, this output is great, and we can tell that it is correct because:</p><ol><li>Fixed points of order <span>$n$</span> are also fixed points of order <span>$2n, 3n, 4n, ...$</span></li><li>Besides fixed points of previous orders, <em>original</em> fixed points of order <span>$n$</span> come in (possible multiples of) <span>$2n$</span>-sized pairs (see e.g. order 5). This is a direct consequence of the Poincaré–Birkhoff theorem.</li></ol><h3 id="Davidchack-and-Lai"><a class="docs-heading-anchor" href="#Davidchack-and-Lai">Davidchack &amp; Lai</a><a id="Davidchack-and-Lai-1"></a><a class="docs-heading-anchor-permalink" href="#Davidchack-and-Lai" title="Permalink"></a></h3><p>An extension of the previous algorithm was proposed by Davidchack &amp; Lai (<a href="../references/#Davidchack1999">Davidchack and Lai, 1999</a>). It works similarly, but it uses smarter seeding and an improved transformation rule.</p><p>The functions <code>davidchacklai</code> implements the algorithm:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChaosTools.davidchacklai" href="#ChaosTools.davidchacklai"><code>ChaosTools.davidchacklai</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">davidchacklai(ds::DeterministicIteratedMap, n::Int, ics, m::Int; kwargs...) -&gt; fps</code></pre><p>Find periodic orbits <code>fps</code> of orders <code>1</code> to <code>n</code> for the map <code>ds</code> using the algorithm propesed by Davidchack &amp; Lai(<a href="../references/#Davidchack1999">Davidchack and Lai, 1999</a>). <code>ics</code> is a collection of initial conditions (container of vectors) to be evolved. <code>ics</code> will be used to detect periodic orbits of orders <code>1</code> to <code>m</code>. These <code>m</code>  periodic orbits will be used to detect periodic orbits of order <code>m+1</code> to <code>n</code>. <code>fps</code> is a vector with <code>n</code> elements. <code>i</code>-th element is a periodic orbit of order <code>i</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>β = nothing</code>: If it is nothing, then <code>β(n) = 10*1.2^n</code>. Otherwise can be a   function that takes period <code>n</code> and return a number. It is a parameter mentioned  in the paper(<a href="../references/#Davidchack1999">Davidchack and Lai, 1999</a>).</li><li><code>maxiters = nothing</code>: If it is nothing, then initial condition will be iterated <code>max(100, 4*β(p))</code> times (where <code>p</code> is the order of the periodic orbit)  before claiming it has not converged. If an integer, then it is the maximum   amount of iterations an initial condition will be iterated before claiming   it has not converged.</li><li><code>disttol = 1e-10</code>: Distance tolerance. If <code>norm(f^{n}(x)-x) &lt; disttol</code>   where <code>f^{n}</code> is the <code>n</code>-th iterate of the dynamic rule <code>f</code>, then <code>x</code>   is an <code>n</code>-periodic point.</li><li><code>abstol = 1e-8</code>: A detected periodic point isn&#39;t stored if it is in <code>abstol</code>   neighborhood of some previously detected point. Distance is measured by   euclidian norm. If you are getting duplicate periodic points, increase this value.</li></ul><p><strong>Description</strong></p><p>The algorithm is an extension of Schmelcher &amp; Diakonos(<a href="../references/#Schmelcher1997">Schmelcher and Diakonos, 1997</a>) implemented in <a href="#ChaosTools.periodicorbits"><code>periodicorbits</code></a>.</p><p>The algorithm can detect periodic orbits by turning fixed points of the original map <code>ds</code> to stable ones, through the transformation</p><p class="math-container">\[\mathbf{x}_{n+1} = \mathbf{x}_{n} + 
[\beta |g(\mathbf{x}_{n})| C^{T} - J(\mathbf{x}_{n})]^{-1} g(\mathbf{x}_{n})\]</p><p>where</p><p class="math-container">\[g(\mathbf{x}_{n}) = f^{n}(\mathbf{x}_{n}) - \mathbf{x}_{n}\]</p><p>and</p><p class="math-container">\[J(\mathbf{x}_{n}) = \frac{\partial g(\mathbf{x}_{n})}{\partial \mathbf{x}_{n}}\]</p><p>The main difference between Schmelcher &amp; Diakonos(<a href="../references/#Schmelcher1997">Schmelcher and Diakonos, 1997</a>) and  Davidchack &amp; Lai(<a href="../references/#Davidchack1999">Davidchack and Lai, 1999</a>) is that the latter uses periodic points of previous period as seeds to detect periodic points of the next period. Additionally, <a href="#ChaosTools.periodicorbits"><code>periodicorbits</code></a> only detects periodic points of a given order,  while <code>davidchacklai</code> detects periodic points of all orders up to <code>n</code>.</p><p><strong>Important note</strong></p><p>For low periods <code>n</code> circa less than 6, you should select <code>m = n</code> otherwise the algorithm  won&#39;t detect periodic orbits correctly. For higher periods, you can select <code>m</code> as 6.  We recommend experimenting with <code>m</code> as it may depend on the specific problem.  Increase <code>m</code> in case the orbits are not being detected correctly.</p><p>Initial conditions <code>ics</code> can be selected as a uniform grid of points in the state space or  subset of a chaotic trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/5476f7189a2463c787efac71c75bddd9cdce8531/src/periodicity/davidchacklai.jl#L3-L68">source</a></section></article><h4 id="Logistic-Map-example"><a class="docs-heading-anchor" href="#Logistic-Map-example">Logistic Map example</a><a id="Logistic-Map-example-1"></a><a class="docs-heading-anchor-permalink" href="#Logistic-Map-example" title="Permalink"></a></h4><p>The idea of periodic orbits can be illustrated easily on 1D maps. Finding all periodic orbits of period <span>$n$</span> is equivalent to finding all points <span>$x$</span> such that <span>$f^{n}(x)=x$</span>, where <span>$f^{n}$</span> is <span>$n$</span>-th composition of <span>$f$</span>. Hence, solving <span>$f^{n}(x)-x=0$</span> yields such points. However, this is often impossible analytically.  Let&#39;s see how <code>davidchacklai</code> deals with it:</p><p>First let&#39;s start with finding first <span>$9$</span> periodic orbits of the logistic map for parameter <span>$3.72$</span>.</p><pre><code class="language-julia hljs">using ChaosTools
using CairoMakie

logistic_rule(x, p, n) = @inbounds SVector(p[1]*x[1]*(1 - x[1]))
ds = DeterministicIteratedMap(logistic_rule, SVector(0.4), [3.72])
seeds = [SVector(i) for i in LinRange(0.0, 1.0, 10)]
output = davidchacklai(ds, 9, seeds, 6; abstol=1e-6, disttol=1e-12)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9-element Vector{Vector{SVector{1, Float64}}}:
 [[0.7311827956985908], [0.0]]
 [[0.38662970705800187], [0.7311827956989247], [0.0], [0.8821874972430735]]
 [[0.7311827956989247], [0.0]]
 [[0.3177034818396079], [0.5808155232915662], [0.0], [0.38662970705800176], [0.806376883615744], [0.9057041264458106], [0.8821874972430734], [0.73118279569892]]
 [[0.0], [0.7311827956989269]]
 [[0.9157520118590331], [0.6299077421471525], [0.286998984442819], [0.9109040211331463], [0.8672212001324516], [0.3866297070580018], [0.7840245795497282], [0.5618878367611084], [0.30190733374979245], [0.8821874972430734], [0.8145709500114354], [0.6761513965685626], [0.7311827956989247], [0.0], [0.7612257106223875], [0.4283527554446087]]
 [[0.7767552610676709], [0.8517090105640062], [0.6674116032936027], [0.8257408809075153], [0.46983887142368663], [0.7656845473197781], [0.9253694005081607], [0.645072274753479], [0.25295568534359186], [0.2569064479741398], [0.7029650765369176], [0.7311827956989247], [0.7101685528640355], [0.0], [0.9266159395216157], [0.5352815080408169]]
 [[0.580815523291563], [0.2752211565830479], [0.37176048427534275], [0.8873814476036359], [0.27922483081767735], [0.9195423913299305], [0.868823210976944], [0.6356815832652796], [0.9057041264458124], [0.7120608293260391]  …  [0.9182577693338777], [0.6732538405098987], [0.8821874972430507], [0.7946496422194083], [0.7311827956989247], [0.38662970705800187], [0.0], [0.31770348183960895], [0.8063768836157453], [0.3092527725503487]]
 [[0.8351397865800463], [0.2439348271350769], [0.7244574163099475], [0.9233919394296619], [0.5925398344373891], [0.5969310175617724], [0.64079266064647], [0.5439224240213731], [0.7642367356877261], [0.929448625260208]  …  [0.7015891525631268], [0.8011894723749792], [0.8562600273540872], [0.45785310962395387], [0.7311827956989247], [0.742582189940082], [0.0], [0.3403126261379589], [0.8950482855441152], [0.9228234528852824]]</code></pre><p>Now to check the results, let&#39;s plot the periodic orbits of period <span>$6$</span>, <span>$7$</span>, <span>$8$</span> and <span>$9$</span>. </p><pre><code class="language-julia hljs">function ydata(ds, order, xdata)
    ydata = typeof(current_state(ds)[1])[]
    for x in xdata
        reinit!(ds, x)
        step!(ds, order)
        push!(ydata, current_state(ds)[1])
    end
    return ydata
end

fig = Figure()
x = LinRange(0.0, 1.0, 1000)
for (order, position)  in zip([6,7,8,9], [(1,1), (1,2), (2,1), (2,2)])
    fpsx = output[order]
    y = ydata(ds, order, [SVector(x0) for x0 in x])
    fpsy = ydata(ds, order, fpsx)
    axis = Axis(fig[position...])
    axis.title = &quot;Order $order&quot;
    lines!(axis, x, x, color=:black, linewidth=0.5)
    lines!(axis, x, y, color = :blue, linewidth=0.7)
    scatter!(axis, [i[1] for i in fpsx], fpsy, color = :red, markersize=5)
end
fig</code></pre><img src="d26fbce1.png" alt="Example block output"/><p>Points <span>$x$</span> which fulfill <span>$f^{n}(x)=x$</span> can be interpreted as an intersection of the function <span>$f^{n}(x)$</span> and the identity <span>$x$</span>. Our result is correct because all the points of the intersection between the identity and the logistic map were found.</p><h4 id="Henon-Map-example"><a class="docs-heading-anchor" href="#Henon-Map-example">Henon Map example</a><a id="Henon-Map-example-1"></a><a class="docs-heading-anchor-permalink" href="#Henon-Map-example" title="Permalink"></a></h4><p>Let&#39;s try to use <code>davidchacklai</code> in higher dimension. We will try to detect  all periodic points of Henon map of period <code>1</code> to <code>14</code>.</p><pre><code class="language-julia hljs">using ChaosTools, CairoMakie

function henon(u0=zeros(2); a = 1.4, b = 0.3)
    return DeterministicIteratedMap(henon_rule, u0, [a,b])
end
henon_rule(x, p, n) = SVector{2}(1.0 - p[1]*x[1]^2 + x[2], p[2]*x[1])

ds = henon()
xs = LinRange(-3.0, 3.0, 10)
ys = LinRange(-10.0, 10.0, 10)
seeds = [SVector{2}(x,y) for x in xs for y in ys]
n = 14
m = 6
output = davidchacklai(ds, n, seeds, m; abstol=1e-7, disttol=1e-10)

fig = Figure()
ax = Axis(fig[1,1])
for result in output
    scatter!(ax, [x[1] for x in result], [x[2] for x in result], markersize=8, color=:blue)
end
fig</code></pre><img src="466e465d.png" alt="Example block output"/><p>The theory of periodic orbits states that UPOs form sort of a skeleton of the chaotic attractor. Our results supports this claim since it closely resembles the Henon attractor.</p><p>Note that in this case parameter <code>m</code> has to be set to at least <code>6</code>. Otherwise, the algorithm  fails to detect orbits of higher periods correctly.</p><p>To check if the detected points are indeed periodic, we can do the following test:</p><pre><code class="language-julia hljs">    orbit14 = output[end]
    c = 0
    for x in orbit14
        set_state!(ds, x)
        step!(ds, 14)
        xn = current_state(ds)
        if ChaosTools.norm(xn - x) &gt; 1e-10
            c += 1
        end
    end
    &quot;$c non-periodic points found in the 14th order orbit.&quot;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;0 non-periodic points found in the 14th order orbit.&quot;</code></pre><p>The same test can be applied to orbits of lower periods.</p><h2 id="Estimating-the-Period"><a class="docs-heading-anchor" href="#Estimating-the-Period">Estimating the Period</a><a id="Estimating-the-Period-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-the-Period" title="Permalink"></a></h2><p>The function <a href="#ChaosTools.estimate_period"><code>estimate_period</code></a> offers ways for estimating the period (either exact for periodic timeseries, or approximate for near-periodic ones) of a given timeseries. We offer five methods to estimate periods, some of which work on evenly sampled data only, and others which accept any data. The figure below summarizes this: <img src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/chaos/periodestimationmethods.png?raw=true" alt/></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChaosTools.estimate_period" href="#ChaosTools.estimate_period"><code>ChaosTools.estimate_period</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">estimate_period(v::Vector, method, t=0:length(v)-1; kwargs...)</code></pre><p>Estimate the period of the signal <code>v</code>, with accompanying time vector <code>t</code>, using the given <code>method</code>.</p><p>If <code>t</code> is an AbstractArray, then it is iterated through to ensure that it&#39;s evenly sampled (if necessary for the algorithm).  To avoid this, you can pass any <code>AbstractRange</code>, like a <code>UnitRange</code> or a <code>LinRange</code>, which are defined to be evenly sampled.</p><p><strong>Methods requiring evenly sampled data</strong></p><p>These methods are faster, but some are error-prone.</p><ul><li><p><code>:periodogram</code> or <code>:pg</code>: Use the fast Fourier transform to compute a  periodogram (power-spectrum) of the given data.  Data must be evenly sampled.</p></li><li><p><code>:multitaper</code> or <code>mt</code>: The multitaper method reduces estimation bias by using multiple independent estimates from the same sample. Data tapers are then windowed and the power spectra are obtained.  Available keywords follow: <code>nw</code> is the time-bandwidth product, and <code>ntapers</code> is the number of tapers. If <code>window</code> is not specified, the signal is tapered with <code>ntapers</code> discrete prolate spheroidal sequences with time-bandwidth product <code>nw</code>. Each sequence is equally weighted; adaptive multitaper is not (yet) supported. If <code>window</code> is specified, each column is applied as a taper. The sum of periodograms is normalized by the total sum of squares of <code>window</code>.</p></li><li><p><code>:autocorrelation</code> or <code>:ac</code>: Use the autocorrelation function (AC). The value where the AC first comes back close to 1 is the period of the signal. The keyword <code>L = length(v)÷10</code> denotes the length of the AC (thus, given the default setting, this method will fail if there less than 10 periods in the signal). The keyword <code>ϵ = 0.2</code> (<code>\epsilon</code>) means that <code>1-ϵ</code> counts as &quot;1&quot; for the AC.</p></li><li><p><code>:yin</code>: The YIN algorithm. An autocorrelation-based method to estimate the fundamental period of the signal. See the original paper <sup class="footnote-reference"><a id="citeref-CheveigneYIN2002" href="#footnote-CheveigneYIN2002">[CheveigneYIN2002]</a></sup> or the implementation <a href="#ChaosTools.yin"><code>yin</code></a>. Sampling rate is taken as <code>sr = 1/mean(diff(t))</code> if not given.</p></li></ul><p>speech and music. The Journal of the Acoustical Society of America, 111(4), 1917-1930.</p><p><strong>Methods not requiring evenly sampled data</strong></p><p>These methods tend to be slow, but versatile and low-error.</p><ul><li><p><code>:lombscargle</code> or <code>:ls</code>: Use the Lomb-Scargle algorithm to compute a periodogram.  The advantage of the Lomb-Scargle method is that it does not require an equally sampled dataset and performs well on undersampled datasets. Constraints have been set on the period, since Lomb-Scargle tends to have false peaks at very low frequencies.  That being said, it&#39;s a very flexible method.  It is extremely customizable, and the keyword arguments that can be passed to it are given <a href="https://juliaastro.github.io/LombScargle.jl/stable/index.html#LombScargle.plan">in the documentation</a>.</p></li><li><p><code>:zerocrossing</code> or <code>:zc</code>: Find the zero crossings of the data, and use the average difference between zero crossings as the period.  This is a naïve implementation, with only linear interpolation; however, it&#39;s useful as a sanity check.  The keyword <code>line</code> controls where the &quot;crossing point&quot; is. It defaults to <code>mean(v)</code>.</p></li></ul><p>For more information on the periodogram methods, see the documentation of DSP.jl and LombScargle.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/5476f7189a2463c787efac71c75bddd9cdce8531/src/periodicity/period.jl#L8-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChaosTools.yin" href="#ChaosTools.yin"><code>ChaosTools.yin</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">yin(sig::Vector, sr::Int; kwargs...) -&gt; F0s, frame_times</code></pre><p>Estimate the fundamental frequency (F0) of the signal <code>sig</code> using the YIN algorithm <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. The signal <code>sig</code> is a vector of points uniformly sampled at a rate <code>sr</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>w_len</code>: size of the analysis window [samples == number of points]</li><li><code>f_step</code>: size of the lag between two consecutive frames [samples == number of points]</li><li><code>f0_min</code>: Minimum fundamental frequency that can be detected [linear frequency]</li><li><code>f0_max</code>: Maximum fundamental frequency that can be detected [linear frequency]</li><li><code>harmonic_threshold</code>: Threshold of detection. The algorithm returns the first minimum of the CMNDF function below this threshold.</li><li><code>diffference_function</code>: The difference function to be used (by default <code>ChaosTools.difference_function_original</code>).</li></ul><p><strong>Description</strong></p><p>The YIN algorithm <sup class="footnote-reference"><a id="citeref-CheveigneYIN2002" href="#footnote-CheveigneYIN2002">[CheveigneYIN2002]</a></sup> estimates the signal&#39;s fundamental frequency <code>F0</code> by basically looking for the period <code>τ0</code>  which minimizes the signal&#39;s autocorrelation. This autocorrelation is calculated for signal segments (frames), composed of two windows of length <code>w_len</code>. Each window is separated by a distance <code>τ</code>, and the idea is that the distance which minimizes the pairwise difference between each window is considered to be the fundamental period <code>τ0</code> of that frame.</p><p>More precisely, the algorithm first computes the cumulative mean normalized difference function (MNDF) between two windows of a frame for several candidate periods <code>τ</code> ranging from <code>τ_min=sr/f0_max</code> to <code>τ_max=sr/f0_min</code>. The MNDF is defined as</p><p class="math-container">\[d_t^\prime(\tau) = \begin{cases}
        1 &amp; \text{if} ~ \tau=0 \\
        d_t(\tau)/\left[{(\frac 1 \tau) \sum_{j=1}^{\tau} d_{t}(j)}\right] &amp; \text{otherwise}
        \end{cases}\]</p><p>where <code>d_t</code> is the difference function:</p><p class="math-container">\[d_t(\tau) = \sum_{j=1}^W (x_j - x_{j+\tau})^2\]</p><p>It then refines the local minima of the MNDF using parabolic (quadratic) interpolation. This is done by taking each minima, along with their first neighbor points, and finding the minimum of the corresponding interpolated parabola. The MNDF minima are substituted by the interpolation minima. Finally, the algorithm chooses the minimum with the smallest period and with a corresponding MNDF below the <code>harmonic threshold</code>. If this doesn&#39;t exist, it chooses the period corresponding to the global minimum. It repeats this for frames starting at the first signal point, and separated by a distance <code>f_step</code> (frames can overlap), and returns the vector of frequencies <code>F0=sr/τ0</code> for each frame, along with the start times of each frame.</p><p>As a note, the physical unit of the frequency is 1/[time], where [time] is decided by the sampling rate <code>sr</code>. If, for instance, the sampling rate is over seconds, then the frequency is in Hertz.</p><p>speech and music. The Journal of the Acoustical Society of America, 111(4), 1917-1930.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/5476f7189a2463c787efac71c75bddd9cdce8531/src/periodicity/yin.jl#L3-L58">source</a></section></article><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>Here we will use a modified FitzHugh-Nagumo system that results in periodic behavior, and then try to estimate its period. First, let&#39;s see the trajectory:</p><pre><code class="language-julia hljs">using ChaosTools, CairoMakie

function FHN(u, p, t)
    e, b, g = p
    v, w = u
    dv = min(max(-2 - v, v), 2 - v) - w
    dw = e*(v - g*w + b)
    return SVector(dv, dw)
end

g, e, b  = 0.8, 0.04, 0.0
p0 = [e, b, g]

fhn = CoupledODEs(FHN, SVector(-2, -0.6667), p0)
T, Δt = 1000.0, 0.1
X, t = trajectory(fhn, T; Δt)
v = X[:, 1]

lines(t, v)</code></pre><img src="37cfa128.png" alt="Example block output"/><p>Examining the figure, one can see that the period of the system is around <code>91</code> time units. To estimate it numerically let&#39;s use some of the methods:</p><pre><code class="language-julia hljs">estimate_period(v, :autocorrelation, t)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">91.0</code></pre><pre><code class="language-julia hljs">estimate_period(v, :periodogram, t)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">91.62720091627202</code></pre><pre><code class="language-julia hljs">estimate_period(v, :zerocrossing, t)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">91.07000000000001</code></pre><pre><code class="language-julia hljs">estimate_period(v, :yin, t; f0_min=0.01)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">91.06992696297132</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Schmelcher1997"><a class="tag is-link" href="#citeref-Schmelcher1997">Schmelcher1997</a>P. Schmelcher &amp; F. K. Diakonos, Phys. Rev. Lett. <strong>78</strong>, pp 4733 (1997)</li><li class="footnote" id="footnote-Pingel2000"><a class="tag is-link" href="#citeref-Pingel2000">Pingel2000</a>D. Pingel <em>et al.</em>, Phys. Rev. E <strong>62</strong>, pp 2119 (2000)</li><li class="footnote" id="footnote-Diakonos1998"><a class="tag is-link" href="#citeref-Diakonos1998">Diakonos1998</a>F. K. Diakonos <em>et al.</em>, Phys. Rev. Lett. <strong>81</strong>, pp 4349 (1998)</li><li class="footnote" id="footnote-CheveigneYIN2002"><a class="tag is-link" href="#citeref-CheveigneYIN2002">CheveigneYIN2002</a>De Cheveigné, A., &amp; Kawahara, H. (2002). YIN, a fundamental frequency estimator for</li><li class="footnote" id="footnote-CheveigneYIN2002"><a class="tag is-link" href="#citeref-CheveigneYIN2002">CheveigneYIN2002</a>De Cheveigné, A., &amp; Kawahara, H. (2002). YIN, a fundamental frequency estimator for</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dimreduction/">« Dimensionality reduction</a><a class="docs-footer-nextpage" href="../rareevents/">Rare events »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 23 September 2024 07:28">Monday 23 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
