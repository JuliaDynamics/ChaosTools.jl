<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lyapunov Exponents · ChaosTools.jl</title><meta name="title" content="Lyapunov Exponents · ChaosTools.jl"/><meta property="og:title" content="Lyapunov Exponents · ChaosTools.jl"/><meta property="twitter:title" content="Lyapunov Exponents · ChaosTools.jl"/><meta name="description" content="Documentation for ChaosTools.jl."/><meta property="og:description" content="Documentation for ChaosTools.jl."/><meta property="twitter:description" content="Documentation for ChaosTools.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ChaosTools.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">ChaosTools.jl</a></li><li><a class="tocitem" href="../orbitdiagram/">Orbit diagrams</a></li><li class="is-active"><a class="tocitem" href>Lyapunov Exponents</a><ul class="internal"><li><a class="tocitem" href="#Lyapunov-Spectrum"><span>Lyapunov Spectrum</span></a></li><li><a class="tocitem" href="#Maximum-Lyapunov-Exponent"><span>Maximum Lyapunov Exponent</span></a></li><li><a class="tocitem" href="#Local-Growth-Rates"><span>Local Growth Rates</span></a></li><li><a class="tocitem" href="#Lyapunov-exponent-from-data"><span>Lyapunov exponent from data</span></a></li></ul></li><li><a class="tocitem" href="../chaos_detection/">Detecting &amp; Categorizing Chaos</a></li><li><a class="tocitem" href="../dimreduction/">Dimensionality reduction</a></li><li><a class="tocitem" href="../periodicity/">Fixed points &amp; Periodicity</a></li><li><a class="tocitem" href="../rareevents/">Rare events</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Lyapunov Exponents</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lyapunov Exponents</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/ChaosTools.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/main/docs/src/lyapunovs.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Lyapunov-Exponents"><a class="docs-heading-anchor" href="#Lyapunov-Exponents">Lyapunov Exponents</a><a id="Lyapunov-Exponents-1"></a><a class="docs-heading-anchor-permalink" href="#Lyapunov-Exponents" title="Permalink"></a></h1><p>Lyapunov exponents measure exponential rates of separation of nearby trajectories in the flow of a dynamical system. The concept of these exponents is best explained in Chapter 3 of <a href="https://link.springer.com/book/10.1007/978-3-030-91032-7">Nonlinear Dynamics</a>, Datseris &amp; Parlitz, Springer 2022. The explanations of the chapter directly utilize the code of the functions in this page.</p><h2 id="Lyapunov-Spectrum"><a class="docs-heading-anchor" href="#Lyapunov-Spectrum">Lyapunov Spectrum</a><a id="Lyapunov-Spectrum-1"></a><a class="docs-heading-anchor-permalink" href="#Lyapunov-Spectrum" title="Permalink"></a></h2><p>The function <code>lyapunovspectrum</code> calculates the entire spectrum of the Lyapunov exponents of a system:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChaosTools.lyapunovspectrum" href="#ChaosTools.lyapunovspectrum"><code>ChaosTools.lyapunovspectrum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lyapunovspectrum(ds::DynamicalSystem, N, k = dimension(ds); kwargs...) -&gt; λs</code></pre><p>Calculate the spectrum of Lyapunov exponents <sup class="footnote-reference"><a id="citeref-Lyapunov1992" href="#footnote-Lyapunov1992">[Lyapunov1992]</a></sup> of <code>ds</code> by applying a QR-decomposition on the parallelepiped defined by the deviation vectors, in total for <code>N</code> evolution steps. Return the spectrum sorted from maximum to minimum. The third argument <code>k</code> is optional, and dictates how many lyapunov exponents to calculate (defaults to <code>dimension(ds)</code>).</p><p>See also <a href="#ChaosTools.lyapunov"><code>lyapunov</code></a>, <a href="#ChaosTools.local_growth_rates"><code>local_growth_rates</code></a>.</p><p><strong>Note:</strong> This function simply initializes a <a href="../#DynamicalSystemsBase.TangentDynamicalSystem"><code>TangentDynamicalSystem</code></a> and calls the method below. This means that the automatic Jacobian is used by default. Initialize manually a <a href="../#DynamicalSystemsBase.TangentDynamicalSystem"><code>TangentDynamicalSystem</code></a> if you have a hand-coded Jacobian.</p><p><strong>Keyword arguments</strong></p><ul><li><code>u0 = current_state(ds)</code>: State to start from.</li><li><code>Ttr = 0</code>: Extra transient time to evolve the system before application of the algorithm. Should be <code>Int</code> for discrete systems. Both the system and the deviation vectors are evolved for this time.</li><li><code>Δt = 1</code>: Time of individual evolutions between successive orthonormalization steps. For continuous systems this is approximate.</li><li><code>show_progress = false</code>: Display a progress bar of the process.</li></ul><p><strong>Description</strong></p><p>The method we employ is &quot;H2&quot; of <sup class="footnote-reference"><a id="citeref-Geist1990" href="#footnote-Geist1990">[Geist1990]</a></sup>, originally stated in <sup class="footnote-reference"><a id="citeref-Benettin1980" href="#footnote-Benettin1980">[Benettin1980]</a></sup>, and explained in educational form in <sup class="footnote-reference"><a id="citeref-DatserisParlitz2022" href="#footnote-DatserisParlitz2022">[DatserisParlitz2022]</a></sup>.</p><p>The deviation vectors defining a <code>D</code>-dimensional parallelepiped in tangent space are evolved using the tangent dynamics of the system (see <a href="../#DynamicalSystemsBase.TangentDynamicalSystem"><code>TangentDynamicalSystem</code></a>). A QR-decomposition at each step yields the local growth rate for each dimension of the parallelepiped. At each step the parallelepiped is re-normalized to be orthonormal. The growth rates are then averaged over <code>N</code> successive steps, yielding the lyapunov exponent spectrum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/ef7f1bfd99556ce0104d81ba9ebc1a5acbd40f4c/src/chaosdetection/lyapunovs/lyapunovspectrum.jl#L5-L51">source</a></section><section><div><pre><code class="language-julia hljs">lyapunovspectrum(tands::TangentDynamicalSystem, N::Int; Ttr, Δt, show_progress)</code></pre><p>The low-level method that is called by <code>lyapunovspectrum(ds::DynamicalSystem, ...)</code>. Use this method for looping over different initial conditions or parameters by calling <a href="@ref"><code>reinit!</code></a> to <code>tands</code>.</p><p>Also use this method if you have a hand-coded Jacobian to pass when creating <code>tands</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/ef7f1bfd99556ce0104d81ba9ebc1a5acbd40f4c/src/chaosdetection/lyapunovs/lyapunovspectrum.jl#L58-L66">source</a></section></article><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>For example, the Lyapunov spectrum of the <a href="http://www.scholarpedia.org/article/Hyperchaos">folded towel map</a> is calculated as:</p><pre><code class="language-julia hljs">using ChaosTools
function towel_rule(x, p, n)
    @inbounds x1, x2, x3 = x[1], x[2], x[3]
    SVector( 3.8*x1*(1-x1) - 0.05*(x2+0.35)*(1-2*x3),
    0.1*( (x2+0.35)*(1-2*x3) - 1 )*(1 - 1.9*x1),
    3.78*x3*(1-x3)+0.2*x2 )
end
function towel_jacob(x, p, n)
    row1 = SVector(3.8*(1 - 2x[1]), -0.05*(1-2x[3]), 0.1*(x[2] + 0.35))
    row2 = SVector(-0.19((x[2] + 0.35)*(1-2x[3]) - 1),  0.1*(1-2x[3])*(1-1.9x[1]),  -0.2*(x[2] + 0.35)*(1-1.9x[1]))
    row3 = SVector(0.0,  0.2,  3.78(1-2x[3]))
    return vcat(row1&#39;, row2&#39;, row3&#39;)
end

ds = DeterministicIteratedMap(towel_rule, [0.085, -0.121, 0.075], nothing)
tands = TangentDynamicalSystem(ds; J = towel_jacob)

λλ = lyapunovspectrum(tands, 10000)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
  0.4322447574770155
  0.37226153520857763
 -3.296655735650821</code></pre><p><code>lyapunovspectrum</code> also works for continuous time systems and will auto-generate a Jacobian function if one is not give. For example,</p><pre><code class="language-julia hljs">function lorenz_rule(u, p, t)
    σ = p[1]; ρ = p[2]; β = p[3]
    du1 = σ*(u[2]-u[1])
    du2 = u[1]*(ρ-u[3]) - u[2]
    du3 = u[1]*u[2] - β*u[3]
    return SVector{3}(du1, du2, du3)
end

lor = CoupledODEs(lorenz_rule, fill(10.0, 3), [10, 32, 8/3])
λλ = lyapunovspectrum(lor, 10000; Δt = 0.1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
   0.9841294033514724
   0.0037920478545314194
 -14.65452158412309</code></pre><p><code>lyapunovspectrum</code> is also very fast:</p><pre><code class="language-julia hljs">using BenchmarkTools
ds = DeterministicIteratedMap(towel_rule, [0.085, -0.121, 0.075], nothing)
tands = TangentDynamicalSystem(ds; J = towel_jacob)

@btime lyapunovspectrum($tands, 10000)</code></pre><pre><code class="nohighlight hljs">  966.500 μs (10 allocations: 576 bytes) # on my laptop</code></pre><p>Here is an example of using <a href="@ref"><code>reinit!</code></a> to efficiently iterate over different parameter values, and parallelize via <code>Threads</code>, to compute the exponents over a given parameter range.</p><pre><code class="language-julia hljs">using ChaosTools, CairoMakie

henon_rule(x, p, n) = SVector{2}(1.0 - p[1]*x[1]^2 + x[2], p[2]*x[1])
henon_jacob(x, p, n) = SMatrix{2,2}(-2*p[1]*x[1], p[2], 1.0, 0.0)
ds = DeterministicIteratedMap(henon_rule, zeros(2), [1.4, 0.3])
tands = TangentDynamicalSystem(ds; J = henon_jacob)

as = 0.8:0.005:1.225;
λs = zeros(length(as), 2)

# Since `DynamicalSystem`s are mutable, we need to copy to parallelize
systems = [deepcopy(tands) for _ in 1:Threads.nthreads()-1]
pushfirst!(systems, tands)

Threads.@threads for i in eachindex(as)
    system = systems[Threads.threadid()]
    set_parameter!(system, 1, as[i])
    λs[i, :] .= lyapunovspectrum(system, 10000; Ttr = 500)
end

fig = Figure()
ax = Axis(fig[1,1]; xlabel = L&quot;a&quot;, ylabel = L&quot;\lambda&quot;)
for j in 1:2
    lines!(ax, as, λs[:, j])
end
fig</code></pre><img src="4b790f47.png" alt="Example block output"/><h2 id="Maximum-Lyapunov-Exponent"><a class="docs-heading-anchor" href="#Maximum-Lyapunov-Exponent">Maximum Lyapunov Exponent</a><a id="Maximum-Lyapunov-Exponent-1"></a><a class="docs-heading-anchor-permalink" href="#Maximum-Lyapunov-Exponent" title="Permalink"></a></h2><p>It is possible to get only the maximum Lyapunov exponent simply by giving <code>1</code> as the third argument of <a href="#ChaosTools.lyapunovspectrum"><code>lyapunovspectrum</code></a>. However, there is a second algorithm that calculates the maximum exponent:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChaosTools.lyapunov" href="#ChaosTools.lyapunov"><code>ChaosTools.lyapunov</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lyapunov(ds::DynamicalSystem, Τ; kwargs...) -&gt; λ</code></pre><p>Calculate the maximum Lyapunov exponent <code>λ</code> using a method due to Benettin <sup class="footnote-reference"><a id="citeref-Benettin1976" href="#footnote-Benettin1976">[Benettin1976]</a></sup>, which simply evolves two neighboring trajectories (one called &quot;given&quot; and one called &quot;test&quot;) while constantly rescaling the test one.</p><p><code>T</code>  denotes the total time of evolution (should be <code>Int</code> for discrete time systems).</p><p>See also <a href="#ChaosTools.lyapunovspectrum"><code>lyapunovspectrum</code></a>, <a href="#ChaosTools.local_growth_rates"><code>local_growth_rates</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>show_progress = false</code>: Display a progress bar of the process.</li><li><code>u0 = initial_state(ds)</code>: Initial condition.</li><li><code>Ttr = 0</code>: Extra &quot;transient&quot; time to evolve the trajectories before starting to measure the exponent. Should be <code>Int</code> for discrete systems.</li><li><code>d0 = 1e-9</code>: Initial &amp; rescaling distance between the two neighboring trajectories.</li><li><code>d0_lower = 1e-3*d0</code>: Lower distance threshold for rescaling.</li><li><code>d0_upper = 1e+3*d0</code>: Upper distance threshold for rescaling.</li><li><code>Δt = 1</code>: Time of evolution between each check rescaling of distance. For continuous time systems this is approximate.</li><li><code>inittest = (u1, d0) -&gt; u1 .+ d0/sqrt(length(u1))</code>: A function that given <code>(u1, d0)</code> initializes the test state with distance <code>d0</code> from the given state <code>u1</code>  (<code>D</code> is the dimension of the system). This function can be used when you want to avoid the test state appearing in a region of the phase-space where it would have e.g. different energy or escape to infinity.</li></ul><p><strong>Description</strong></p><p>Two neighboring trajectories with initial distance <code>d0</code> are evolved in time. At time <span>$t_i$</span> if their distance <span>$d(t_i)$</span> either exceeds the <code>d0_upper</code>, or is lower than <code>d0_lower</code>, the test trajectory is rescaled back to having distance <code>d0</code> from the reference one, while the rescaling keeps the difference vector along the maximal expansion/contraction direction: <span>$u_2 \to u_1+(u_2−u_1)/(d(t_i)/d_0)$</span>.</p><p>The maximum Lyapunov exponent is the average of the time-local Lyapunov exponents</p><p class="math-container">\[\lambda = \frac{1}{t_{n} - t_0}\sum_{i=1}^{n}
\ln\left( a_i \right),\quad a_i = \frac{d(t_{i})}{d_0}.\]</p><p><strong>Performance notes</strong></p><p>This function simply initializes a <a href="../#DynamicalSystemsBase.ParallelDynamicalSystem"><code>ParallelDynamicalSystem</code></a> and calls the method below.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/ef7f1bfd99556ce0104d81ba9ebc1a5acbd40f4c/src/chaosdetection/lyapunovs/lyapunov.jl#L3-L51">source</a></section><section><div><pre><code class="language-julia hljs">lyapunov(pds::ParallelDynamicalSystem, T; Ttr, Δt, d0, d0_upper, d0_lower)</code></pre><p>The low-level method that is called by <code>lyapunov(ds::DynamicalSystem, ...)</code>. Use this method for looping over different initial conditions or parameters by calling <a href="@ref"><code>reinit!</code></a> to <code>pds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/ef7f1bfd99556ce0104d81ba9ebc1a5acbd40f4c/src/chaosdetection/lyapunovs/lyapunov.jl#L66-L72">source</a></section></article><p>For example:</p><pre><code class="language-julia hljs">using ChaosTools
henon_rule(x, p, n) = SVector{2}(1.0 - p[1]*x[1]^2 + x[2], p[2]*x[1])
henon = DeterministicIteratedMap(henon_rule, zeros(2), [1.4, 0.3])
λ = lyapunov(henon, 10000; d0 = 1e-7, d0_upper = 1e-4, Ttr = 100)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.42018736282059616</code></pre><h2 id="Local-Growth-Rates"><a class="docs-heading-anchor" href="#Local-Growth-Rates">Local Growth Rates</a><a id="Local-Growth-Rates-1"></a><a class="docs-heading-anchor-permalink" href="#Local-Growth-Rates" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChaosTools.local_growth_rates" href="#ChaosTools.local_growth_rates"><code>ChaosTools.local_growth_rates</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">local_growth_rates(ds::DynamicalSystem, points::StateSpaceSet; kwargs...) → λlocal</code></pre><p>Compute the local exponential growth rate(s) of perturbations of the dynamical system <code>ds</code> for initial conditions given in <code>points</code>. For each initial condition <code>u ∈ points</code>, <code>S</code> total perturbations are created and evolved exactly for time <code>Δt</code>. The exponential local growth rate is defined simply by <code>log(g/g0)/Δt</code> with <code>g0</code> the initial perturbation size and <code>g</code> the size after <code>Δt</code>. Thus, <code>λlocal</code> is a matrix of size <code>(length(points), S)</code>.</p><p>This function is a modification of <a href="#ChaosTools.lyapunov"><code>lyapunov</code></a>. It uses the full nonlinear dynamics and a <a href="../#DynamicalSystemsBase.ParallelDynamicalSystem"><code>ParallelDynamicalSystem</code></a> to evolve the perturbations, but does not do any re-scaling, thus allowing probing state and time dependence of perturbation growth. The actual growth is given by <code>exp(λlocal * Δt)</code>.</p><p>The output of this function is sometimes called &quot;Nonlinear Local Lyapunov Exponent&quot;.</p><p><strong>Keyword arguments</strong></p><ul><li><code>S = 100</code></li><li><code>Δt = 5</code></li><li><code>perturbation</code>: If given, it should be a function <code>perturbation(ds, u, j)</code> that outputs a perturbation vector (preferrably <code>SVector</code>) given the system, current initial condition <code>u</code> and the counter <code>j ∈ 1:S</code>. If not given, a random perturbation is generated with norm given by the keyword <code>e = 1e-6</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/ef7f1bfd99556ce0104d81ba9ebc1a5acbd40f4c/src/chaosdetection/lyapunovs/local_growth_rates.jl#L3-L27">source</a></section></article><p>Here is a simple example using the Henon map</p><pre><code class="language-julia hljs">using ChaosTools
using Statistics, CairoMakie

henon_rule(x, p, n) = SVector{2}(1.0 - p[1]*x[1]^2 + x[2], p[2]*x[1])
he = DeterministicIteratedMap(henon_rule, zeros(2), [1.4, 0.3])
points = trajectory(he, 2000; Ttr = 100)[1]

λlocal = local_growth_rates(he, points; Δt = 1)

λmeans = mean(λlocal; dims = 2)
λstds = std(λlocal; dims = 2)
x, y = columns(points)
fig, ax, obj = scatter(x, y; color = vec(λmeans))
Colorbar(fig[1,2], obj)
fig</code></pre><img src="bc0c3323.png" alt="Example block output"/><h2 id="Lyapunov-exponent-from-data"><a class="docs-heading-anchor" href="#Lyapunov-exponent-from-data">Lyapunov exponent from data</a><a id="Lyapunov-exponent-from-data-1"></a><a class="docs-heading-anchor-permalink" href="#Lyapunov-exponent-from-data" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChaosTools.lyapunov_from_data" href="#ChaosTools.lyapunov_from_data"><code>ChaosTools.lyapunov_from_data</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lyapunov_from_data(R::StateSpaceSet, ks; kwargs...)</code></pre><p>For the given dataset <code>R</code>, which is expected to represent a trajectory of a dynamical system, calculate and return <code>E(k)</code>, which is the average logarithmic distance between states of a neighborhood that are evolved in time for <code>k</code> steps (<code>k</code> must be integer). The slope of <code>E</code> vs <code>k</code> approximates the maximum Lyapunov exponent.</p><p>Typically <code>R</code> is the result of delay coordinates embedding of a timeseries (see DelayEmbeddings.jl).</p><p><strong>Keyword arguments</strong></p><ul><li><code>refstates = 1:(length(R) - ks[end])</code>: Vector of indices that notes which states of the dataset should be used as &quot;reference states&quot;, which means that the algorithm is applied for all state indices contained in <code>refstates</code>.</li><li><code>w::Int = 1</code>: The <a href="@ref">Theiler window</a>.</li><li><code>ntype = NeighborNumber(1)</code>: The neighborhood type. Either <a href="#Neighborhood.NeighborNumber"><code>NeighborNumber</code></a> or <a href="#Neighborhood.WithinRange"><code>WithinRange</code></a>. See <a href="@ref">Neighborhoods</a> for more info.</li><li><code>distance = FirstElement()</code>: Specifies what kind of distance function is used in the logarithmic distance of nearby states. Allowed distances values are <code>FirstElement()</code> or <code>Euclidean()</code>, see below for more info. The metric for finding neighbors is always the Euclidean one.</li></ul><p><strong>Description</strong></p><p>If the dataset exhibits exponential divergence of nearby states, then it should hold</p><p class="math-container">\[E(k) \approx \lambda\cdot k \cdot \Delta t + E(0)\]</p><p>for a <em>well defined region</em> in the <span>$k$</span> axis, where <span>$\lambda$</span> is the approximated maximum Lyapunov exponent. <span>$\Delta t$</span> is the time between samples in the original timeseries. You can use <a href="@ref"><code>linear_region</code></a> with arguments <code>(ks .* Δt, E)</code> to identify the slope (= <span>$\lambda$</span>) immediately, assuming you have chosen sufficiently good <code>ks</code> such that the linear scaling region is bigger than the saturated region.</p><p>The algorithm used in this function is due to Parlitz<sup class="footnote-reference"><a id="citeref-Skokos2016" href="#footnote-Skokos2016">[Skokos2016]</a></sup>, which itself expands upon Kantz<sup class="footnote-reference"><a id="citeref-Kantz1994" href="#footnote-Kantz1994">[Kantz1994]</a></sup>. In sort, for each reference state a neighborhood is evaluated. Then, for each point in this neighborhood, the logarithmic distance between reference state and neighborhood state(s) is calculated as the &quot;time&quot; index <code>k</code> increases. The average of the above over all neighborhood states over all reference states is the returned result.</p><p>If the <code>distance</code> is <code>Euclidean()</code> then use the Euclidean distance of the full <code>D</code>-dimensional points (distance <span>$d_E$</span> in ref.<sup class="footnote-reference"><a id="citeref-Skokos2016" href="#footnote-Skokos2016">[Skokos2016]</a></sup>). If however the <code>distance</code> is <code>FirstElement()</code>, calculate the absolute distance of <em>only the first elements</em> of the points of <code>R</code> (distance <span>$d_F$</span> in ref.<sup class="footnote-reference"><a id="citeref-Skokos2016" href="#footnote-Skokos2016">[Skokos2016]</a></sup>, useful when <code>R</code> comes from delay embedding).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/ef7f1bfd99556ce0104d81ba9ebc1a5acbd40f4c/src/chaosdetection/lyapunovs/lyapunov_from_data.jl#L10-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Neighborhood.NeighborNumber" href="#Neighborhood.NeighborNumber"><code>Neighborhood.NeighborNumber</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NeighborNumber(k::Int) &lt;: SearchType</code></pre><p>Search type representing the <code>k</code> nearest neighbors of the query (or approximate neighbors, depending on the search structure).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaNeighbors/Neighborhood.jl/blob/v0.2.4/src/api.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Neighborhood.WithinRange" href="#Neighborhood.WithinRange"><code>Neighborhood.WithinRange</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WithinRange(r::Real) &lt;: SearchType</code></pre><p>Search type representing all neighbors with distance <code>≤ r</code> from the query (according to the search structure&#39;s metric).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaNeighbors/Neighborhood.jl/blob/v0.2.4/src/api.jl#L27-L31">source</a></section></article><p>Let&#39;s apply the method to a timeseries from a continuous time system. In this case, one must be a bit more thoughtful when choosing parameters. The following example helps the users get familiar with the process:</p><pre><code class="language-julia hljs">using ChaosTools, CairoMakie

function lorenz_rule(u, p, t)
    σ = p[1]; ρ = p[2]; β = p[3]
    du1 = σ*(u[2]-u[1])
    du2 = u[1]*(ρ-u[3]) - u[2]
    du3 = u[1]*u[2] - β*u[3]
    return SVector{3}(du1, du2, du3)
end

ds = CoupledODEs(lorenz_rule, fill(10.0, 3), [10, 32, 8/3])
# create a timeseries of 1 dimension
Δt = 0.05
x = trajectory(ds, 1000.0; Ttr = 10, Δt)[1][:, 1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">20001-element Vector{Float64}:
  4.08037314705637
  4.240648211911674
  4.995736623638859
  6.360963428947034
  8.368663200977597
 10.871010893236175
 13.195165389349793
 14.068943434393853
 12.64585168053599
  9.674355464277134
  ⋮
  8.486922916293155
  3.5647851073728964
  0.4275203896593395
 -1.4028346675741428
 -2.6065379752401108
 -3.7015437907307533
 -5.0486104029408985
 -6.907578479398829
 -9.395707401961825</code></pre><p>From prior knowledge of the system, we know we need to use <code>k</code> up to about <code>150</code>. However, due to the dense time sampling, we don&#39;t have to compute for every <code>k</code> in the range <code>0:150</code>. Instead, we can use</p><pre><code class="language-julia hljs">ks = 0:4:150</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0:4:148</code></pre><p>Now we plot some example computations using delay embeddings to &quot;reconstruct&quot; the chaotic attractor</p><pre><code class="language-julia hljs">using DelayEmbeddings: embed
fig = Figure()
ax = Axis(fig[1,1]; xlabel=&quot;k (0.05×t)&quot;, ylabel=&quot;E - E(0)&quot;)
ntype = NeighborNumber(5) #5 nearest neighbors of each state

for d in [4, 8], τ in [7, 15]
    r = embed(x, d, τ)

    # E1 = lyapunov_from_data(r, ks1; ntype)
    # λ1 = ChaosTools.linreg(ks1 .* Δt, E1)[2]
    # plot(ks1,E1.-E1[1], label = &quot;dense, d=$(d), τ=$(τ), λ=$(round(λ1, 3))&quot;)

    E2 = lyapunov_from_data(r, ks; ntype)
    λ2 = ChaosTools.linreg(ks .* Δt, E2)[2]
    lines!(ks, E2.-E2[1]; label = &quot;d=$(d), τ=$(τ), λ=$(round(λ2, digits = 3))&quot;)
end
axislegend(ax; position = :lt)
ax.title = &quot;Continuous Reconstruction Lyapunov&quot;
fig</code></pre><img src="86552504.png" alt="Example block output"/><p>As you can see, using <code>τ = 15</code> is not a great choice! The estimates with <code>τ = 7</code> though are very good (the actual value is around <code>λ ≈ 0.89...</code>). Notice that above a linear regression was done over the whole curves, which doesn&#39;t make sense. One should identify a linear scaling region and extract the slope of that one. The function <code>linear_region</code> from <a href="https://github.com/JuliaDynamics/FractalDimensions.jl">FractalDimensions.jl</a> does this!</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Lyapunov1992"><a class="tag is-link" href="#citeref-Lyapunov1992">Lyapunov1992</a>A. M. Lyapunov, <em>The General Problem of the Stability of Motion</em>, Taylor &amp; Francis (1992)</li><li class="footnote" id="footnote-Geist1990"><a class="tag is-link" href="#citeref-Geist1990">Geist1990</a>K. Geist <em>et al.</em>, Progr. Theor. Phys. <strong>83</strong>, pp 875 (1990)</li><li class="footnote" id="footnote-Benettin1980"><a class="tag is-link" href="#citeref-Benettin1980">Benettin1980</a>G. Benettin <em>et al.</em>, Meccanica <strong>15</strong>, pp 9-20 &amp; 21-30 (1980)</li><li class="footnote" id="footnote-DatserisParlitz2022"><a class="tag is-link" href="#citeref-DatserisParlitz2022">DatserisParlitz2022</a>Datseris &amp; Parlitz 2022, <em>Nonlinear Dynamics: A Concise Introduction Interlaced with Code</em>, <a href="https://doi.org/10.1007/978-3-030-91032-7">Springer Nature, Undergrad. Lect. Notes In Physics</a></li><li class="footnote" id="footnote-Benettin1976"><a class="tag is-link" href="#citeref-Benettin1976">Benettin1976</a>G. Benettin <em>et al.</em>, Phys. Rev. A <strong>14</strong>, pp 2338 (1976)</li><li class="footnote" id="footnote-Skokos2016"><a class="tag is-link" href="#citeref-Skokos2016">Skokos2016</a>Skokos, C. H. <em>et al.</em>, <em>Chaos Detection and Predictability</em> - Chapter 1 (section 1.3.2), Lecture Notes in Physics <strong>915</strong>, Springer (2016)</li><li class="footnote" id="footnote-Kantz1994"><a class="tag is-link" href="#citeref-Kantz1994">Kantz1994</a>Kantz, H., Phys. Lett. A <strong>185</strong>, pp 77–87 (1994)</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../orbitdiagram/">« Orbit diagrams</a><a class="docs-footer-nextpage" href="../chaos_detection/">Detecting &amp; Categorizing Chaos »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 23 September 2024 12:16">Monday 23 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
