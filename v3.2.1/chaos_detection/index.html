<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Detecting &amp; Categorizing Chaos · ChaosTools.jl</title><meta name="title" content="Detecting &amp; Categorizing Chaos · ChaosTools.jl"/><meta property="og:title" content="Detecting &amp; Categorizing Chaos · ChaosTools.jl"/><meta property="twitter:title" content="Detecting &amp; Categorizing Chaos · ChaosTools.jl"/><meta name="description" content="Documentation for ChaosTools.jl."/><meta property="og:description" content="Documentation for ChaosTools.jl."/><meta property="twitter:description" content="Documentation for ChaosTools.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ChaosTools.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">ChaosTools.jl</a></li><li><a class="tocitem" href="../orbitdiagram/">Orbit diagrams</a></li><li><a class="tocitem" href="../lyapunovs/">Lyapunov Exponents</a></li><li class="is-active"><a class="tocitem" href>Detecting &amp; Categorizing Chaos</a><ul class="internal"><li><a class="tocitem" href="#Generalized-Alignment-Index"><span>Generalized Alignment Index</span></a></li><li><a class="tocitem" href="#Predictability-of-a-chaotic-system"><span>Predictability of a chaotic system</span></a></li><li><a class="tocitem" href="#The-0-1-test-for-chaos"><span>The 0-1 test for chaos</span></a></li><li><a class="tocitem" href="#Expansion-entropy"><span>Expansion entropy</span></a></li></ul></li><li><a class="tocitem" href="../dimreduction/">Dimensionality reduction</a></li><li><a class="tocitem" href="../periodicity/">Fixed points &amp; Periodicity</a></li><li><a class="tocitem" href="../rareevents/">Rare events</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Detecting &amp; Categorizing Chaos</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Detecting &amp; Categorizing Chaos</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/ChaosTools.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/main/docs/src/chaos_detection.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Detecting-and-Categorizing-Chaos"><a class="docs-heading-anchor" href="#Detecting-and-Categorizing-Chaos">Detecting &amp; Categorizing Chaos</a><a id="Detecting-and-Categorizing-Chaos-1"></a><a class="docs-heading-anchor-permalink" href="#Detecting-and-Categorizing-Chaos" title="Permalink"></a></h1><p>Being able to detect and distinguish chaotic from regular behavior is crucial in the study of dynamical systems. Most of the time a positive maximum <a href="../lyapunovs/#ChaosTools.lyapunov"><code>lyapunov</code></a> exponent and a bounded system indicate chaos.</p><p>However, the convergence of the Lyapunov exponent can be slow, or even misleading, as the types of chaotic behavior vary with respect to their predictability. There are some alternatives, some more efficient and some more accurate in characterizing chaotic and regular motion.</p><h2 id="Generalized-Alignment-Index"><a class="docs-heading-anchor" href="#Generalized-Alignment-Index">Generalized Alignment Index</a><a id="Generalized-Alignment-Index-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-Alignment-Index" title="Permalink"></a></h2><p>&quot;GALI&quot; for sort, is a method that relies on the fact that initially orthogonal deviation vectors tend to align towards the direction of the maximum Lyapunov exponent for chaotic motion. It is one of the most recent and cheapest methods for distinguishing chaotic and regular behavior, introduced first in 2007 by Skokos, Bountis &amp; Antonopoulos.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChaosTools.gali" href="#ChaosTools.gali"><code>ChaosTools.gali</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gali(ds::DynamicalSystem, T, k::Int; kwargs...) -&gt; GALI_k, t</code></pre><p>Compute <span>$\text{GALI}_k$</span><sup class="footnote-reference"><a id="citeref-Skokos2007" href="#footnote-Skokos2007">[Skokos2007]</a></sup> for a given <code>k</code> up to time <code>T</code>. Return <span>$\text{GALI}_k(t)$</span> and time vector <span>$t$</span>.</p><p>The third argument sets the order of <code>gali</code>. <code>gali</code> function simply initializes a <a href="../#DynamicalSystemsBase.TangentDynamicalSystem"><code>TangentDynamicalSystem</code></a> with <code>k</code> deviation vectors and calls the method below. This means that the automatic Jacobian is used by default. Initialize manually a <a href="../#DynamicalSystemsBase.TangentDynamicalSystem"><code>TangentDynamicalSystem</code></a> if you have a hand-coded Jacobian.</p><p><strong>Keyword arguments</strong></p><ul><li><code>threshold = 1e-12</code>: If <code>GALI_k</code> falls below the <code>threshold</code> iteration is terminated.</li><li><code>Δt = 1</code>: Time-step between deviation vector normalizations. For continuous systems this is approximate.</li><li><code>u0</code>: Initial state for the system. Defaults to <code>current_state(ds)</code>.</li></ul><p><strong>Description</strong></p><p>The Generalized Alignment Index, <span>$\text{GALI}_k$</span>, is an efficient (and very fast) indicator of chaotic or regular behavior type in <span>$D$</span>-dimensional Hamiltonian systems (<span>$D$</span> is number of variables). The <em>asymptotic</em> behavior of <span>$\text{GALI}_k(t)$</span> depends critically on the type of orbit resulting from the initial condition. If it is a chaotic orbit, then</p><p class="math-container">\[\text{GALI}_k(t) \sim
\exp\left[\sum_{j=1}^k (\lambda_1 - \lambda_j)t \right]\]</p><p>with <span>$\lambda_j$</span> being the <code>j</code>-th Lyapunov exponent (see <a href="../lyapunovs/#ChaosTools.lyapunov"><code>lyapunov</code></a>, <a href="../lyapunovs/#ChaosTools.lyapunovspectrum"><code>lyapunovspectrum</code></a>). If on the other hand the orbit is regular, corresponding to movement in <span>$d$</span>-dimensional torus with <span>$1 \le d \le D/2$</span> then it holds</p><p class="math-container">\[\text{GALI}_k(t) \sim
    \begin{cases}
      \text{const.}, &amp; \text{if} \;\; 2 \le k \le d  \; \; \text{and}
      \; \;d &gt; 1 \\
      t^{-(k - d)}, &amp; \text{if} \;\;  d &lt; k \le D - d \\
      t^{-(2k - D)}, &amp; \text{if} \;\;  D - d &lt; k \le D
    \end{cases}\]</p><p>Traditionally, if <span>$\text{GALI}_k(t)$</span> does not become less than the <code>threshold</code> until <code>T</code> the given orbit is said to be chaotic, otherwise it is regular.</p><p>Our implementation is not based on the original paper, but rather in the method described in<sup class="footnote-reference"><a id="citeref-Skokos2016b" href="#footnote-Skokos2016b">[Skokos2016b]</a></sup>, which uses the product of the singular values of <span>$A$</span>, a matrix that has as <em>columns</em> the deviation vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/ef7f1bfd99556ce0104d81ba9ebc1a5acbd40f4c/src/chaosdetection/gali.jl#L4-L64">source</a></section><section><div><pre><code class="language-julia hljs">gali(tands::TangentDynamicalSystem, T; threshold = 1e-12, Δt = 1)</code></pre><p>The low-level method that is called by <code>gali(ds::DynamicalSystem, ...)</code>. Use this method for looping over different initial conditions or parameters by calling <a href="@ref"><code>reinit!</code></a> to <code>tands</code>.</p><p>The order of <span>$\text{GALI}_k$</span> computed is the amount of deviation vectors in <code>tands</code>.</p><p>Also use this method if you have a hand-coded Jacobian to pass when creating <code>tands</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/ef7f1bfd99556ce0104d81ba9ebc1a5acbd40f4c/src/chaosdetection/gali.jl#L72-L82">source</a></section></article><h3 id="GALI-example"><a class="docs-heading-anchor" href="#GALI-example">GALI example</a><a id="GALI-example-1"></a><a class="docs-heading-anchor-permalink" href="#GALI-example" title="Permalink"></a></h3><p>As an example let&#39;s use the Henon-Heiles system</p><pre><code class="language-julia hljs">using ChaosTools, CairoMakie
using OrdinaryDiffEq: Vern9

function henonheiles_rule(u, p, t)
    SVector(u[3], u[4],
        -u[1] - 2u[1]*u[2],
        -u[2] - (u[1]^2 - u[2]^2),
    )
end
function henonheiles_jacob(u, p, t)
    SMatrix{4,4}(0, 0, -1 - 2u[2], -2u[1], 0, 0,
     -2u[1], -1 + 2u[2], 1, 0, 0, 0, 0, 1, 0, 0)
end

u0=[0, -0.25, 0.42081, 0]
Δt = 1.0
diffeq = (abstol=1e-9, retol=1e-9, alg = Vern9(), maxiters = typemax(Int))
sp = [0, .295456, .407308431, 0] # stable periodic orbit: 1D torus
qp = [0, .483000, .278980390, 0] # quasiperiodic orbit: 2D torus
ch = [0, -0.25, 0.42081, 0]      # chaotic orbit
ds = CoupledODEs(henonheiles_rule, sp)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-dimensional CoupledODEs
 deterministic: true
 discrete time: false
 in-place:      false
 dynamic rule:  henonheiles_rule
 ODE solver:    Tsit5
 ODE kwargs:    (abstol = 1.0e-6, reltol = 1.0e-6)
 parameters:    SciMLBase.NullParameters()
 time:          0.0
 state:         [0.0, 0.295456, 0.407308431, 0.0]
</code></pre><p>Let&#39;s see what happens with a quasi-periodic orbit:</p><pre><code class="language-julia hljs">tr = trajectory(ds, 10000.0, qp; Δt)[1]
fig, ax = scatter(tr[:,1], tr[:,3]; label=&quot;qp&quot;, markersize=2)
axislegend(ax)

ax = Axis(fig[1,2]; yscale = log)
for k in [2,3,4]
    g, t = gali(ds, 10000.0, k; u0 = qp, Δt)
    logt = log.(t)
    lines!(ax, logt, g; label=&quot;GALI_$(k)&quot;)
    if k == 2
        lines!(ax, logt, 1 ./ t.^(2k-4); label=&quot;slope -$(2k-4)&quot;)
    else
        lines!(ax, logt, 100 ./ t.^(2k-4); label=&quot;slope -$(2k-4)&quot;)
    end
end
ylims!(ax, 1e-12, 2)
fig</code></pre><img src="94a935b4.png" alt="Example block output"/><p>And here is GALI of a continuous system with a chaotic orbit</p><pre><code class="language-julia hljs">tr = trajectory(ds, 10000.0, ch; Δt)[1]
fig, ax = scatter(tr[:,1], tr[:,3]; label=&quot;ch&quot;, markersize=2, color = (Main.COLORS[1], 0.5))
axislegend(ax)

ax = Axis(fig[1,2]; yscale = log)
ls = lyapunovspectrum(ds, 5000; Δt, u0 = ch)
for k in [2,3,4]
    ex = sum(ls[1] - ls[j] for j in 2:k)
    g, t = gali(ds, 1000, k; u0 = ch, Δt)
    lines!(t, exp.(-ex.*t); label=&quot;exp. k=$k&quot;)
    lines!(t, g; label=&quot;GALI_$(k)&quot;)
end
ylims!(ax, 1e-16, 1)
fig</code></pre><img src="0de70cb9.png" alt="Example block output"/><h3 id="Using-GALI"><a class="docs-heading-anchor" href="#Using-GALI">Using GALI</a><a id="Using-GALI-1"></a><a class="docs-heading-anchor-permalink" href="#Using-GALI" title="Permalink"></a></h3><p>No-one in their right mind would try to fit power-laws in order to distinguish between chaotic and regular behavior, like the above examples. These were just proofs that the method works as expected.</p><p>The most common usage of <span>$\text{GALI}_k$</span> is to define a (sufficiently) small amount of time and a (sufficiently) small threshold and see whether <span>$\text{GALI}_k$</span> stays below it, for a (sufficiently) big <span>$k$</span>.</p><p>For example, we utilize parallel integration of <code>TangentDynamicalSystem</code> to compute <span>$GALI$</span> for many initial conditions and produce a color-coded map of regular and chaotic orbits of the standard map.</p><p>The following is an example of advanced usage:</p><pre><code class="language-julia hljs">using ChaosTools, CairoMakie
# Initialize `TangentDynamicalSystem`
@inbounds function standardmap_rule(x, par, n)
    theta = x[1]; p = x[2]
    p += par[1]*sin(theta)
    theta += p
    return mod2pi.(SVector(theta, p))
end
@inbounds standardmap_jacob(x, p, n) = SMatrix{2,2}(
    1 + p[1]*cos(x[1]), p[1]*cos(x[1]), 1, 1
)
ds = DeterministicIteratedMap(standardmap_rule, ones(2), [1.0])
tands = TangentDynamicalSystem(ds; J = standardmap_jacob)
# Collect initial conditions
dens = 101
θs = ps = range(0, stop = 2π, length = dens)
ics = vec(SVector{2, Float64}.(Iterators.product(θs, ps)))
# Initialize as many systems as threads
systems = [deepcopy(tands) for _ in 1:Threads.nthreads()-1]
pushfirst!(systems, tands)
# Perform threaded loop
regularity = zeros(size(ics))
Threads.@threads for i in eachindex(ics)
    u0 = ics[i]
    system = systems[Threads.threadid()]
    reinit!(system, u0)
    regularity[i] = gali(system, 500)[2][end]
end
# Visualize
fig, ax, sc = scatter(ics; color = regularity)
Colorbar(fig[1,2], sc; label = &quot;regularity&quot;)
fig</code></pre><img src="0b9060de.png" alt="Example block output"/><h2 id="Predictability-of-a-chaotic-system"><a class="docs-heading-anchor" href="#Predictability-of-a-chaotic-system">Predictability of a chaotic system</a><a id="Predictability-of-a-chaotic-system-1"></a><a class="docs-heading-anchor-permalink" href="#Predictability-of-a-chaotic-system" title="Permalink"></a></h2><p>Even if a system is &quot;formally&quot; chaotic, it can still be in phases where it is partially predictable, because the correlation coefficient between nearby trajectories vanishes very slowly with time. <a href="https://www.nature.com/articles/s41598-017-01083-x">Wernecke, Sándor &amp; Gros</a> have developed an algorithm that allows one to classify a dynamical system to one of three categories: strongly chaotic, partially predictable chaos or regular (called <em>laminar</em> in their paper).</p><p>We have implemented their algorithm in the function <a href="#ChaosTools.predictability"><code>predictability</code></a>. Note that we set up the implementation to always return regular behavior for negative Lyapunov exponent. You may want to override this for research purposes.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChaosTools.predictability" href="#ChaosTools.predictability"><code>ChaosTools.predictability</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predictability(ds::CoreDynamicalSystem; kwargs...) -&gt; chaos_type, ν, C</code></pre><p>Determine whether <code>ds</code> displays strongly chaotic, partially-predictable chaotic or regular behaviour, using the method by Wernecke et al. described in<sup class="footnote-reference"><a id="citeref-Wernecke2017" href="#footnote-Wernecke2017">[Wernecke2017]</a></sup>.</p><p>Return the type of the behavior, the cross-distance scaling coefficient <code>ν</code> and the correlation coefficient <code>C</code>. Typical values for <code>ν</code>, <code>C</code> and <code>chaos_type</code> are given in Table 2 of<sup class="footnote-reference"><a id="citeref-Wernecke2017" href="#footnote-Wernecke2017">[Wernecke2017]</a></sup>:</p><table><tr><th style="text-align: right"><code>chaos_type</code></th><th style="text-align: right"><code>ν</code></th><th style="text-align: right"><code>C</code></th></tr><tr><td style="text-align: right"><code>:SC</code></td><td style="text-align: right">0</td><td style="text-align: right">0</td></tr><tr><td style="text-align: right"><code>:PPC</code></td><td style="text-align: right">0</td><td style="text-align: right">1</td></tr><tr><td style="text-align: right"><code>:REG</code></td><td style="text-align: right">1</td><td style="text-align: right">1</td></tr></table><p>If none of these conditions apply, the return value is <code>:IND</code> (for indeterminate).</p><p><strong>Keyword arguments</strong></p><ul><li><code>Ttr = 200</code>: Extra transient time to evolve the system before sampling from  the trajectory. Should be <code>Int</code> for discrete systems.</li><li><code>T_sample = 1e4</code>: Time to evolve the system for taking samples. Should be <code>Int</code> for discrete systems.</li><li><code>n_samples = 500</code>: Number of samples to take for use in calculating statistics.</li><li><code>λ_max = lyapunov(ds, 5000)</code>: Value to use for largest Lyapunov exponent for finding the Lyapunov prediction time. If it is less than zero a regular result is returned immediately.</li><li><code>d_tol = 1e-3</code>: tolerance distance to use for calculating Lyapunov prediction time.</li><li><code>T_multiplier = 10</code>: Multiplier from the Lyapunov prediction time to the evaluation time.</li><li><code>T_max = Inf</code>: Maximum time at which to evaluate trajectory distance. If the internally  computed evaluation time is larger than <code>T_max</code>, stop at <code>T_max</code> instead.  <strong>It is strongly recommended to manually set this!</strong></li><li><code>δ_range = 10.0 .^ (-9:-6)</code>: Range of initial condition perturbation distances  to use to determine scaling <code>ν</code>.</li><li><code>ν_threshold = C_threshold = 0.5</code>: Thresholds for scaling coefficients (they become 0 or 1 if they are less or more than the threshold).</li></ul><p><strong>Description</strong></p><p>The algorithm samples points from a trajectory of the system to be used as initial conditions. Each of these initial conditions is randomly perturbed by a distance <code>δ</code>, and the trajectories for both the original and perturbed initial conditions are evolved up to the &#39;evaluation time&#39; <code>T</code> (see below its definition).</p><p>The average (over the samples) distance and cross-correlation coefficient of the state at time <code>T</code> is computed. This is repeated for a range of <code>δ</code> (defined by <code>δ_range</code>), and linear regression is used to determine how the distance and cross-correlation scale with <code>δ</code>, allowing for identification of chaos type.</p><p>The evaluation time <code>T</code> is calculated as <code>T = T_multiplier*Tλ</code>, where the Lyapunov prediction time <code>Tλ = log(d_tol/δ)/λ_max</code>. This may be very large if the <code>λ_max</code> is small, e.g. when the system is regular, so this internally computed time <code>T</code> can be overridden by a smaller <code>T_max</code> set by the user.</p><p><strong>Performance Notes</strong></p><p>For continuous systems, it is likely that the <code>maxiters</code> used by the integrators needs to be increased, e.g. to 1e9. This is part of the <code>diffeq</code> kwargs. In addition, be aware that this function does a <em>lot</em> of internal computations. It is operating in a different speed than e.g. <a href="../lyapunovs/#ChaosTools.lyapunov"><code>lyapunov</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/ef7f1bfd99556ce0104d81ba9ebc1a5acbd40f4c/src/chaosdetection/partially_predictable.jl#L10-L75">source</a></section></article><h3 id="Example-Hénon-Map"><a class="docs-heading-anchor" href="#Example-Hénon-Map">Example Hénon Map</a><a id="Example-Hénon-Map-1"></a><a class="docs-heading-anchor-permalink" href="#Example-Hénon-Map" title="Permalink"></a></h3><p>We will create something similar to figure 2 of the paper, but for the Hénon map.</p><pre><code class="language-julia hljs">fig = Figure()
ax = Axis(fig[1,1]; xlabel = L&quot;a&quot;, ylabel = L&quot;x&quot;)
henon_rule(x, p, n) = SVector{2}(1.0 - p[1]*x[1]^2 + x[2], p[2]*x[1])
he = DeterministicIteratedMap(henon_rule, zeros(2), [1.4, 0.3])
as = 0.8:0.01:1.225
od = orbitdiagram(he, 1, 1, as; n = 2000, Ttr = 2000)
colors = Dict(:REG =&gt; &quot;blue&quot;, :PPC =&gt; &quot;green&quot;, :SC =&gt; &quot;red&quot;)
for (i, a) in enumerate(as)
    set_parameter!(he, 1, a)
    chaos_type, ν, C = predictability(he; T_max = 400000, Ttr = 2000)
    scatter!(ax, a .* ones(length(od[i])), od[i];
    color = (colors[chaos_type], 0.05), markersize = 2)
end
ax.title = &quot;predictability of Hénon map&quot;
fig</code></pre><img src="299af929.png" alt="Example block output"/><h2 id="The-0-1-test-for-chaos"><a class="docs-heading-anchor" href="#The-0-1-test-for-chaos">The 0-1 test for chaos</a><a id="The-0-1-test-for-chaos-1"></a><a class="docs-heading-anchor-permalink" href="#The-0-1-test-for-chaos" title="Permalink"></a></h2><p>The methods mentioned in this page so far require a <code>DynamicalSystem</code> instance. But of course this is not always the case. The so-called &quot;0 to 1&quot; test for chaos, by Gottwald &amp; Melbourne, takes as an input a timeseries and outputs a boolean <code>true</code> if the timeseries is chaotic or <code>false</code> if it is not.</p><p>Notice that the method does have a lot of caveats, so you should read the review paper before using. Also, it doesn&#39;t work for noisy data.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChaosTools.testchaos01" href="#ChaosTools.testchaos01"><code>ChaosTools.testchaos01</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">testchaos01(x::Vector [, cs, N0]) -&gt; chaotic?</code></pre><p>Perform the so called &quot;0-1&quot; test for chaos introduced by Gottwald and Melbourne<sup class="footnote-reference"><a id="citeref-Gottwald2016" href="#footnote-Gottwald2016">[Gottwald2016]</a></sup> on the timeseries <code>x</code>. Return <code>true</code> if <code>x</code> is chaotic, <code>false</code> otherwise.</p><p><strong>Description</strong></p><p>This method tests if the given timeseries is chaotic or not by transforming it into a two-dimensional diffusive process like so:</p><p class="math-container">\[p_n = \sum_{j=1}^{n}\phi_j \cos(j c),\quad q_n = \sum_{j=1}^{n}\phi_j \sin(j c)\]</p><p>If the timeseries is chaotic, the mean square displacement of the process grows as <code>sqrt(length(x))</code>, while it stays constant if the timeseries is regular.</p><p>The implementation here computes <code>K</code>, a coefficient measuring the growth of the mean square displacement, and simply checks if <code>K &gt; 0.5</code>. <code>K</code> is the median of <span>$K_c$</span> over given <code>c</code>, see the reference.</p><p>If you want to access the various <code>Kc</code> you should call the method <code>testchaos01(x, c::Real, N0)</code> which returns <code>Kc</code>. In fact, the high level method is just <code>median(testchaos01(x, c, N0) for c in cs) &gt; 0.5</code>.</p><p><code>cs</code> defaults to <code>3π/5*rand(100) + π/4</code> and <code>N0</code>, the length of the two-dimensional process, is <code>N0 = length(x)/10</code>.</p><p>For data sampled from continuous dynamical systems, some care must be taken regarding the values of <code>cs</code>. Also note that this method performs rather poorly with even the slight amount of noise, returning <code>true</code> for even small amounts of noise noisy timeseries. Some possibilities to alleviate this exist, but are context specific on the application. See <sup class="footnote-reference"><a id="citeref-Gottwald2016" href="#footnote-Gottwald2016">[Gottwald2016]</a></sup> for more info.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/ef7f1bfd99556ce0104d81ba9ebc1a5acbd40f4c/src/chaosdetection/testchaos01.jl#L5-L46">source</a></section></article><h2 id="Expansion-entropy"><a class="docs-heading-anchor" href="#Expansion-entropy">Expansion entropy</a><a id="Expansion-entropy-1"></a><a class="docs-heading-anchor-permalink" href="#Expansion-entropy" title="Permalink"></a></h2><p>The expansion entropy is a quantity that is suggested by B. Hunt and E. Ott as a measure that can define chaos (so far no widely accepted definition of chaos exists). Positive expansion entropy means chaos.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChaosTools.expansionentropy" href="#ChaosTools.expansionentropy"><code>ChaosTools.expansionentropy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expansionentropy(ds::DynamicalSystem, sampler, isinside; kwargs...)</code></pre><p>Calculate the expansion entropy<sup class="footnote-reference"><a id="citeref-Hunt2015" href="#footnote-Hunt2015">[Hunt2015]</a></sup> of <code>ds</code>, in the restraining region <span>$S$</span> by estimating the slope (via linear regression) of the curve <span>$\log E_{t0+T, t0}(f, S)$</span> versus <span>$T$</span> (using <a href="@ref"><code>linear_region</code></a>). This is an approximation of the expansion entropy <span>$H_0$</span>, according to<sup class="footnote-reference"><a id="citeref-Hunt2015" href="#footnote-Hunt2015">[Hunt2015]</a></sup>. Return <span>$T$</span>,  <span>$\log E$</span> and the calculated slope.</p><p><code>sampler</code> is a 0-argument function that generates a random initial conditions of <code>ds</code> and <code>isinside</code> is a 1-argument function that given a state it returns true if the state is inside the restraining region. Typically <code>sampler, isinside</code> are the output of <a href="@ref"><code>statespace_sampler</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>N = 1000</code>: Number of samples taken at each batch (same as <span>$N$</span> of <sup class="footnote-reference"><a id="citeref-Hunt2015" href="#footnote-Hunt2015">[Hunt2015]</a></sup>).</li><li><code>steps = 40</code>: The maximal steps for which the system will be run.</li><li><code>batches = 100</code>: Number of batches to run the calculation, see below.</li><li><code>Δt = 1</code>: Time evolution step size.</li><li><code>J = nothing</code>: Jacobian function given to <a href="../#DynamicalSystemsBase.TangentDynamicalSystem"><code>TangentDynamicalSystem</code></a>.</li></ul><p><strong>Description</strong></p><p><code>N</code> samples are initialized and propagated forwards in time (along with their tangent space). At every time <span>$t$</span> in <code>[t0+Δt, t0+2Δt, ..., t0+steps*Δt]</code> we calculate <span>$H$</span>:</p><p class="math-container">\[H[t] = \log E_{t0+T, t0}(f, S),\]</p><p>with</p><p class="math-container">\[E_{t0+T, t0}(f, S) = \frac 1 N \sum_{i&#39;} G(Df_{t0+t, t0}(x_i))\]</p><p>(using same notation as <sup class="footnote-reference"><a id="citeref-Hunt2015" href="#footnote-Hunt2015">[Hunt2015]</a></sup>). In principle <span>$E$</span> is the average largest possible growth ratio within the restraining region (sampled by the initial conditions). The summation is only over <span>$x_i$</span> that stay inside the region <span>$S$</span> defined by the boolean function <code>isinside</code>. This process is done by the <code>ChaosTools.expansionentropy_sample</code> function.</p><p>Then, this is repeated for <code>batches</code> amount of times, as recommended in<sup class="footnote-reference"><a id="citeref-Hunt2015" href="#footnote-Hunt2015">[Hunt2015]</a></sup>. From all these batches, the mean and std of <span>$H$</span> is computed at every time point. This is done by the <a href="@ref"><code>expansionentropy_batch</code></a> function. When plotted versus <span>$t$</span>, these create the curves and error bars of e.g. Figs 2, 3 of [1].</p><p>This function <code>expansionentropy</code> simply returns the slope of the biggest linear region of the curve <span>$H$</span> versus <span>$t$</span>, which approximates the expansion entropy <span>$H_0$</span>. It is therefore <em>recommended</em> to use <a href="@ref"><code>expansionentropy_batch</code></a> directly and evaluate the result yourself, as this step is known to be inaccurate for non-chaotic systems (where <span>$H$</span> fluctuates strongly around 0).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/ef7f1bfd99556ce0104d81ba9ebc1a5acbd40f4c/src/chaosdetection/expansionentropy.jl#L5-L56">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Skokos2007"><a class="tag is-link" href="#citeref-Skokos2007">Skokos2007</a>Skokos, C. H. <em>et al.</em>, Physica D <strong>231</strong>, pp 30–54 (2007)</li><li class="footnote" id="footnote-Skokos2016b"><a class="tag is-link" href="#citeref-Skokos2016b">Skokos2016b</a>Skokos, C. H. <em>et al.</em>, <em>Chaos Detection and Predictability</em> - Chapter 5 (section 5.3.1 and ref. [85] therein), Lecture Notes in Physics <strong>915</strong>, Springer (2016)</li><li class="footnote" id="footnote-Wernecke2017"><a class="tag is-link" href="#citeref-Wernecke2017">Wernecke2017</a>Wernecke, H., Sándor, B. &amp; Gros, C. <em>How to test for partially predictable chaos</em>. <a href="https://www.nature.com/articles/s41598-017-01083-x">Scientific Reports <strong>7</strong>, (2017)</a>.</li><li class="footnote" id="footnote-Gottwald2016"><a class="tag is-link" href="#citeref-Gottwald2016">Gottwald2016</a>Gottwald &amp; Melbourne, “The 0-1 test for chaos: A review” <a href=" www.doi.org/10.1007/978-3-662-48410-4_7">Lect. Notes Phys., vol. 915, pp. 221–247, 2016.</a></li><li class="footnote" id="footnote-Hunt2015"><a class="tag is-link" href="#citeref-Hunt2015">Hunt2015</a>Hunt &amp; Ott, ‘Defining Chaos’, <a href="https://doi.org/10/gdtkcf">Chaos 25.9 (2015)</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lyapunovs/">« Lyapunov Exponents</a><a class="docs-footer-nextpage" href="../dimreduction/">Dimensionality reduction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 23 September 2024 12:16">Monday 23 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
