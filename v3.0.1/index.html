<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ChaosTools.jl · ChaosTools.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ChaosTools.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>ChaosTools.jl</a><ul class="internal"><li><a class="tocitem" href="#DynamicalSystemsBase.jl-reference"><span>DynamicalSystemsBase.jl reference</span></a></li></ul></li><li><a class="tocitem" href="orbitdiagram/">Orbit diagrams</a></li><li><a class="tocitem" href="lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="chaos_detection/">Detecting &amp; Categorizing Chaos</a></li><li><a class="tocitem" href="dimreduction/">Dimensionality reduction</a></li><li><a class="tocitem" href="periodicity/">Fixed points &amp; Periodicity</a></li><li><a class="tocitem" href="rareevents/">Rare events</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>ChaosTools.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ChaosTools.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/main/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ChaosTools.jl"><a class="docs-heading-anchor" href="#ChaosTools.jl">ChaosTools.jl</a><a id="ChaosTools.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ChaosTools.jl" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ChaosTools" href="#ChaosTools"><code>ChaosTools</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>ChaosTools.jl</strong></p><p><a href="https://JuliaDynamics.github.io/ChaosTools.jl/dev"><img src="https://img.shields.io/badge/docs-dev-lightblue.svg" alt/></a> <a href="https://JuliaDynamics.github.io/ChaosTools.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt/></a> <a href="https://link.springer.com/book/10.1007/978-3-030-91032-7"><img src="https://img.shields.io/badge/DOI-10.1007%2F978--3--030--91032--7-purple" alt/></a> <a href="https://github.com/JuliaDynamics/ChaosTools.jl/actions?query=workflow%3ACI"><img src="https://github.com/JuliaDynamics/ChaosTools.jl/workflows/CI/badge.svg" alt="CI"/></a> <a href="https://codecov.io/gh/JuliaDynamics/ChaosTools.jl"><img src="https://codecov.io/gh/JuliaDynamics/ChaosTools.jl/branch/main/graph/badge.svg" alt="codecov"/></a> <a href="https://pkgs.genieframework.com?packages=ChaosTools"><img src="https://shields.io/endpoint?url=https://pkgs.genieframework.com/api/v1/badge/ChaosTools" alt="Package Downloads"/></a></p><p>A Julia module that offers various tools for analysing nonlinear dynamics and chaotic behaviour. It can be used as a standalone package, or as part of <a href="https://juliadynamics.github.io/DynamicalSystems.jl/dev/">DynamicalSystems.jl</a>.</p><p>To install it, run <code>import Pkg; Pkg.add(&quot;ChaosTools&quot;)</code>.</p><p>All further information is provided in the documentation, which you can either find <a href="https://juliadynamics.github.io/ChaosTools.jl/dev/">online</a> or build locally by running the <code>docs/make.jl</code> file.</p><p><em>ChaosTools.jl is the jack-of-all-trades package of the DynamicalSystems.jl library: methods that are not extensive enough to be a standalone package are added here. You should see the full DynamicalSystems.jl library for other packages that may contain functionality you are looking for but did not find in ChaosTools.jl.</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ChaosTools.jl/blob/e66542747f971cabeb94046b90c6eaf439916064/src/ChaosTools.jl#L4-L22">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Accompanying textbook</header><div class="admonition-body"><p>A good background for understanding the methods of ChaosTools.jl is the following textbook: <a href="https://link.springer.com/book/10.1007/978-3-030-91032-7">Nonlinear Dynamics</a>, Datseris &amp; Parlitz, Springer 2022.</p></div></div><h2 id="DynamicalSystemsBase.jl-reference"><a class="docs-heading-anchor" href="#DynamicalSystemsBase.jl-reference">DynamicalSystemsBase.jl reference</a><a id="DynamicalSystemsBase.jl-reference-1"></a><a class="docs-heading-anchor-permalink" href="#DynamicalSystemsBase.jl-reference" title="Permalink"></a></h2><p>As many docstrings in ChaosTools.jl point to the different <code>DynamicalSystem</code> types, they are also provided here for reference.</p><ul><li><a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a></li><li><a href="#DynamicalSystemsBase.DeterministicIteratedMap"><code>DeterministicIteratedMap</code></a></li><li><a href="#DynamicalSystemsBase.CoupledODEs"><code>CoupledODEs</code></a></li><li><a href="#DynamicalSystemsBase.CoreDynamicalSystem"><code>CoreDynamicalSystem</code></a></li><li><a href="#DynamicalSystemsBase.StroboscopicMap"><code>StroboscopicMap</code></a></li><li><a href="#DynamicalSystemsBase.PoincareMap"><code>PoincareMap</code></a></li><li><a href="#DynamicalSystemsBase.TangentDynamicalSystem"><code>TangentDynamicalSystem</code></a></li><li><a href="#DynamicalSystemsBase.ParallelDynamicalSystem"><code>ParallelDynamicalSystem</code></a></li><li><a href="#DynamicalSystemsBase.ProjectedDynamicalSystem"><code>ProjectedDynamicalSystem</code></a></li><li><a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.DynamicalSystem" href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystemsBase.DynamicalSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DynamicalSystem</code></pre><p><code>DynamicalSystem</code> is an abstract supertype encompassing all concrete implementations of what counts as a &quot;dynamical system&quot; in the DynamicalSystems.jl library.</p><p><strong><em>All concrete implementations of <code>DynamicalSystem</code> can be iteratively evolved in time via the <a href="@ref"><code>step!</code></a> function.</em></strong> Hence, most library functions that evolve the system will mutate its current state and/or parameters. See the documentation online for implications this has on for parallelization.</p><p><code>DynamicalSystem</code> is further separated into two abstract types: <code>ContinuousTimeDynamicalSystem, DiscreteTimeDynamicalSystem</code>. The simplest and most common concrete implementations of a <code>DynamicalSystem</code> are <a href="#DynamicalSystemsBase.DeterministicIteratedMap"><code>DeterministicIteratedMap</code></a> or <a href="#DynamicalSystemsBase.CoupledODEs"><code>CoupledODEs</code></a>.</p><p><strong>Description</strong></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The documentation of <code>DynamicalSystem</code> follows chapter 1 of <a href="https://link.springer.com/book/10.1007/978-3-030-91032-7">Nonlinear Dynamics</a>, Datseris &amp; Parlitz, Springer 2022.</p></div></div><p>A <code>ds::DynamicalSystem</code> <strong><em>representes a flow Φ in a state space</em></strong>. It mainly encapsulates three things:</p><ol><li>A state, typically referred to as <code>u</code>, with initial value <code>u0</code>. The space that <code>u</code> occupies is the state space of <code>ds</code> and the length of <code>u</code> is the dimension of <code>ds</code> (and of the state space).</li><li>A dynamic rule, typically referred to as <code>f</code>, that dictates how the state evolves/changes with time when calling the <a href="@ref"><code>step!</code></a> function. <code>f</code> is a standard Julia function, see below.</li><li>A parameter container <code>p</code> that parameterizes <code>f</code>. <code>p</code> can be anything, but in general it is recommended to be a type-stable mutable container.</li></ol><p>In sort, any set of quantities that change in time can be considered a dynamical system, however the concrete subtypes of <code>DynamicalSystem</code> are much more specific in their scope. Concrete subtypes typically also contain more information than the above 3 items.</p><p>In this scope dynamical systems have a known dynamic rule <code>f</code> defined as a standard Julia function. <em>Observed</em> or <em>measured</em> data from a dynamical system are represented using <code>StateSpaceSet</code> and are finite. Such data are obtained from the <a href="@ref"><code>trajectory</code></a> function or from an experimental measurement of a dynamical system with an unknown dynamic rule.</p><p><strong>Construction instructions on <code>f</code> and <code>u</code></strong></p><p>Most of the concrete implementations of <code>DynamicalSystem</code>, with the exception of <a href="@ref"><code>ArbitrarySteppable</code></a>, have two ways of implementing the dynamic rule <code>f</code>, and as a consequence the type of the state <code>u</code>. The distinction is done on whether <code>f</code> is defined as an in-place (iip) function or out-of-place (oop) function.</p><ul><li><strong>oop</strong> : <code>f</code> <strong>must</strong> be in the form <code>f(u, p, t) -&gt; out</code>   which means that given a state <code>u::SVector{&lt;:Real}</code> and some parameter container   <code>p</code> it returns the output of <code>f</code> as an <code>SVector{&lt;:Real}</code> (static vector).</li><li><strong>iip</strong> : <code>f</code> <strong>must</strong> be in the form <code>f!(out, u, p, t)</code>   which means that given a state <code>u::AbstractArray{&lt;:Real}</code> and some parameter container <code>p</code>,   it writes in-place the output of <code>f</code> in <code>out::AbstractArray{&lt;:Real}</code>.   The function <strong>must</strong> return <code>nothing</code> as a final statement.</li></ul><p><code>t</code> stands for current time in both cases. <strong>iip</strong> is suggested for systems with high dimension and <strong>oop</strong> for small. The break-even point is between 10 to 100 dimensions but should be benchmarked on a case-by-case basis as it depends on the complexity of <code>f</code>.</p><div class="admonition is-info"><header class="admonition-header">Autonomous vs non-autonomous systems</header><div class="admonition-body"><p>Whether the dynamical system is autonomous (<code>f</code> doesn&#39;t depend on time) or not, it is still necessary to include <code>t</code> as an argument to <code>f</code>. Some algorithms utilize this information, some do not, but we prefer to keep a consistent interface either way. You can also convert any system to autonomous by making time an additional variable. If the system is non-autonomous, its <em>effective dimensionality</em> is <code>dimension(ds)+1</code>.</p></div></div><p><strong>API</strong></p><p>The API that the interface of <code>DynamicalSystem</code> employs is the functions listed below. Once a concrete instance of a subtype of <code>DynamicalSystem</code> is obtained, it can quieried or altered with the following functions.</p><p>The main use of a concrete dynamical system instance is to provide it to downstream functions such as <code>lyapunovspectrum</code> from ChaosTools.jl or <code>basins_of_attraction</code> from Attractors.jl. A typical user will likely not utilize directly the following API, unless when developing new algorithm implementations that use dynamical systems.</p><p><strong>API - information</strong></p><ul><li><code>ds(t)</code> with <code>ds</code> an instance of <code>DynamicalSystem</code>: return the state of <code>ds</code> at time <code>t</code>. For continuous time systems this interpolates and extrapolates, while for discrete time systems it only works if <code>t</code> is the current time.</li><li><a href="@ref"><code>current_state</code></a></li><li><a href="@ref"><code>initial_state</code></a></li><li><a href="@ref"><code>current_parameters</code></a></li><li><a href="@ref"><code>initial_parameters</code></a></li><li><a href="@ref"><code>isdeterministic</code></a></li><li><a href="@ref"><code>isdiscretetime</code></a></li><li><a href="@ref"><code>dynamic_rule</code></a></li><li><a href="@ref"><code>current_time</code></a></li><li><a href="@ref"><code>initial_time</code></a></li><li><a href="@ref"><code>isinplace</code></a></li></ul><p><strong>API - alter status</strong></p><ul><li><a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a></li><li><a href="@ref"><code>set_state!</code></a></li><li><a href="@ref"><code>set_parameter!</code></a></li><li><a href="@ref"><code>set_parameters!</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.DeterministicIteratedMap" href="#DynamicalSystemsBase.DeterministicIteratedMap"><code>DynamicalSystemsBase.DeterministicIteratedMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DeterministicIteratedMap &lt;: DynamicalSystem
DeterministicIteratedMap(f, u0, p = nothing; t0 = 0)</code></pre><p>A deterministic discrete time dynamical system defined by an iterated map as follows:</p><p class="math-container">\[\vec{u}_{n+1} = \vec{f}(\vec{u}_n, p, n)\]</p><p>An alias for <code>DeterministicIteratedMap</code> is <code>DiscreteDynamicalSystem</code>.</p><p>Optionally configure the parameter container <code>p</code> and initial time <code>t0</code>.</p><p>For construction instructions regarding <code>f, u0</code> see <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.CoupledODEs" href="#DynamicalSystemsBase.CoupledODEs"><code>DynamicalSystemsBase.CoupledODEs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CoupledODEs &lt;: ContinuousTimeDynamicalSystem
CoupledODEs(f, u0 [, p]; diffeq, t0 = 0.0)</code></pre><p>A deterministic continuous time dynamical system defined by a set of coupled ordinary differential equations as follows:</p><p class="math-container">\[\frac{d\vec{u}}{dt} = \vec{f}(\vec{u}, p, t)\]</p><p>An alias for <code>CoupledODE</code> is <code>ContinuousDynamicalSystem</code>.</p><p>Optionally provide the parameter container <code>p</code> and initial time as keyword <code>t0</code>.</p><p>For construction instructions regarding <code>f, u0</code> see <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a>.</p><p><strong>DifferentialEquations.jl keyword arguments and interfacing</strong></p><p>The ODEs are evolved via the solvers of DifferentialEquations.jl. When initializing a <code>CoupledODEs</code>, you can specify the solver that will integrate <code>f</code> in time, along with any other integration options, using the <code>diffeq</code> keyword. For example you could use <code>diffeq = (abstol = 1e-9, reltol = 1e-9)</code>. If you want to specify a solver, do so by using the keyword <code>alg</code>, e.g.: <code>diffeq = (alg = Tsit5(), reltol = 1e-6)</code>. This requires you to have been first <code>using OrdinaryDiffEq</code> to access the solvers. The default <code>diffeq</code> is:</p><p>(alg = Tsit5(stage<em>limiter! = trivial</em>limiter!, step<em>limiter! = trivial</em>limiter!, thread = static(false)), abstol = 1.0e-6, reltol = 1.0e-6)</p><p><code>diffeq</code> keywords can also include <code>callback</code> for <a href="http://docs.juliadiffeq.org/latest/features/callback_functions.html">event handling </a>, however the majority of downstream functions in DynamicalSystems.jl assume that <code>f</code> is differentiable.</p><p>The convenience constructor <code>CoupledODEs(prob::ODEProblem, diffeq)</code> and <code>CoupledODEs(ds::CoupledODEs, diffeq)</code> are also available.</p><p>Dev note: <code>CoupledODEs</code> is a light wrapper of <code>ODEIntegrator</code> from DifferentialEquations.jl. The integrator is available as the field <code>integ</code>, and the <code>ODEProblem</code> is <code>integ.sol.prob</code>. The convenience syntax <code>ODEProblem(ds::CoupledODEs, tspan = (t0, Inf))</code> is available.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.CoreDynamicalSystem" href="#DynamicalSystemsBase.CoreDynamicalSystem"><code>DynamicalSystemsBase.CoreDynamicalSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CoreDynamicalSystem</code></pre><p>Union type meaning either <a href="#DynamicalSystemsBase.DeterministicIteratedMap"><code>DeterministicIteratedMap</code></a> or <a href="#DynamicalSystemsBase.CoupledODEs"><code>CoupledODEs</code></a>, which are the core systems whose dynamic rule <code>f</code> is known analytically.</p><p>This type is used for deciding whether a creation of a <a href="#DynamicalSystemsBase.TangentDynamicalSystem"><code>TangentDynamicalSystem</code></a> is possible or not.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.StroboscopicMap" href="#DynamicalSystemsBase.StroboscopicMap"><code>DynamicalSystemsBase.StroboscopicMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StroboscopicMap &lt;: DiscreteTimeDynamicalSystem
StroboscopicMap(ds::CoupledODEs, period::Real) → smap
StroboscopicMap(period::Real, f, u0, p = nothing; kwargs...)</code></pre><p>A discrete time dynamical system that produces iterations of a time-dependent (non-autonomous) <a href="#DynamicalSystemsBase.CoupledODEs"><code>CoupledODEs</code></a> system exactly over a given <code>period</code>. The second signature first creates a <a href="#DynamicalSystemsBase.CoupledODEs"><code>CoupledODEs</code></a> and then calls the first.</p><p><code>StroboscopicMap</code> follows the <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a> interface. In addition, the function <code>set_period!(smap, period)</code> is provided, that sets the period of the system to a new value (as if it was a parameter). As this system is in discrete time, <a href="@Ref"><code>current_time</code></a> and <a href="@ref"><code>initial_time</code></a> are integers. The initial time is always 0, because <code>current_time</code> counts elapsed periods. Call these functions on the <code>parent</code> of <code>StroboscopicMap</code> to obtain the corresponding continuous time. In contrast, <a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a> expects <code>t0</code> in continuous time.</p><p>The convenience constructor</p><pre><code class="language-julia hljs">StroboscopicMap(T::Real, f, u0, p = nothing; diffeq, t0 = 0) → smap</code></pre><p>is also provided.</p><p>See also <a href="#DynamicalSystemsBase.PoincareMap"><code>PoincareMap</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.PoincareMap" href="#DynamicalSystemsBase.PoincareMap"><code>DynamicalSystemsBase.PoincareMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PoincareMap &lt;: DiscreteTimeDynamicalSystem
PoincareMap(ds::CoupledODEs, plane; kwargs...) → pmap</code></pre><p>A discrete time dynamical system that produces iterations over the Poincaré map<sup class="footnote-reference"><a id="citeref-DatserisParlitz2022" href="#footnote-DatserisParlitz2022">[DatserisParlitz2022]</a></sup> of the given continuous time <code>ds</code>. This map is defined as the sequence of points on the Poincaré surface of section, which is defined by the <code>plane</code> argument.</p><p>See also <a href="#DynamicalSystemsBase.StroboscopicMap"><code>StroboscopicMap</code></a>, <a href="@ref"><code>poincaresos</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>direction = -1</code>: Only crossings with <code>sign(direction)</code> are considered to belong to the surface of section. Positive direction means going from less than <span>$b$</span> to greater than <span>$b$</span>.</li><li><code>u0 = nothing</code>: Specify an initial state.</li><li><code>rootkw = (xrtol = 1e-6, atol = 1e-8)</code>: A <code>NamedTuple</code> of keyword arguments passed to <code>find_zero</code> from <a href="https://github.com/JuliaMath/Roots.jl">Roots.jl</a>.</li><li><code>Tmax = 1e3</code>: The argument <code>Tmax</code> exists so that the integrator can terminate instead of being evolved for infinite time, to avoid cases where iteration would continue forever for ill-defined hyperplanes or for convergence to fixed points, where the trajectory would never cross again the hyperplane. If during one <code>step!</code> the system has been evolved for more than <code>Tmax</code>, then <code>step!(pmap)</code> will terminate and error.</li></ul><p><strong>Description</strong></p><p>The Poincaré surface of section is defined as sequential transversal crossings a trajectory has with any arbitrary manifold, but here the manifold must be a hyperplane. <code>PoincareMap</code> iterates over the crossings of the section.</p><p>If the state of <code>ds</code> is <span>$\mathbf{u} = (u_1, \ldots, u_D)$</span> then the equation defining a hyperplane is</p><p class="math-container">\[a_1u_1 + \dots + a_Du_D = \mathbf{a}\cdot\mathbf{u}=b\]</p><p>where <span>$\mathbf{a}, b$</span> are the parameters of the hyperplane.</p><p>In code, <code>plane</code> can be either:</p><ul><li>A <code>Tuple{Int, &lt;: Real}</code>, like <code>(j, r)</code>: the plane is defined as when the <code>j</code>th variable of the system equals the value <code>r</code>.</li><li>A vector of length <code>D+1</code>. The first <code>D</code> elements of the vector correspond to <span>$\mathbf{a}$</span> while the last element is <span>$b$</span>.</li></ul><p><code>PoincareMap</code> uses <code>ds</code>, higher order interpolation from DifferentialEquations.jl, and root finding from Roots.jl, to create a high accuracy estimate of the section.</p><p><code>PoincareMap</code> follows the <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a> interface with the following adjustments:</p><ol><li><code>dimension(pmap) == dimension(ds)</code>, even though the Poincaré map is effectively 1 dimension less.</li><li>Like <a href="#DynamicalSystemsBase.StroboscopicMap"><code>StroboscopicMap</code></a> time is discrete and counts the iterations on the surface of section. <a href="@ref"><code>initial_time</code></a> is always <code>0</code> and <a href="@ref"><code>current_time</code></a> is current iteration number.</li><li>A new function <a href="@ref"><code>current_crossing_time</code></a> returns the real time corresponding to the latest crossing of the hyperplane, which is what the <a href="@ref"><code>current_state(ds)</code></a> corresponds to as well.</li><li>For the special case of <code>plane</code> being a <code>Tuple{Int, &lt;:Real}</code>, a special <code>reinit!</code> method is allowed with input state of length <code>D-1</code> instead of <code>D</code>, i.e., a reduced state already on the hyperplane that is then converted into the <code>D</code> dimensional state.</li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs">using DynamicalSystemsBase
ds = Systems.rikitake(zeros(3); μ = 0.47, α = 1.0)
pmap = poincaremap(ds, (3, 0.0))
step!(pmap)
next_state_on_psos = current_state(pmap)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.TangentDynamicalSystem" href="#DynamicalSystemsBase.TangentDynamicalSystem"><code>DynamicalSystemsBase.TangentDynamicalSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TangentDynamicalSystem &lt;: DynamicalSystem
TangentDynamicalSystem(ds::CoreDynamicalSystem; kwargs...)</code></pre><p>A dynamical system that bundles the evolution of <code>ds</code> (which must be an <a href="#DynamicalSystemsBase.CoreDynamicalSystem"><code>CoreDynamicalSystem</code></a>) and <code>k</code> deviation vectors that are evolved according to the <em>dynamics in the tangent space</em> (also called linearized dynamics or the tangent dynamics).</p><p>The state of <code>ds</code> <strong>must</strong> be an <code>AbstractVector</code> for <code>TangentDynamicalSystem</code>.</p><p><code>TangentDynamicalSystem</code> follows the <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a> interface with the following adjustments:</p><ul><li><code>reinit!</code> takes an additional keyword <code>Q0</code> (with same default as below)</li><li>The additional functions <a href="@ref"><code>current_deviations</code></a> and <a href="@ref"><code>set_deviations!</code></a> are provided for the deviation vectors.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>k</code> or <code>Q0</code>: <code>Q0</code> represents the initial deviation vectors (each column = 1 vector). If <code>k::Int</code> is given, a matrix <code>Q0</code> is created with the first <code>k</code> columns of the identity matrix. Otherwise <code>Q0</code> can be given directly as a matrix. It must hold that <code>size(Q, 1) == dimension(ds)</code>. You can use <a href="@ref"><code>orthonormal</code></a> for random orthonormal vectors. By default <code>k = dimension(ds)</code> is used.</li><li><code>u0 = current_state(ds)</code>: Starting state.</li><li><code>J</code> and <code>J0</code>: See section &quot;Jacobian&quot; below.</li></ul><p><strong>Description</strong></p><p>Let <span>$u$</span> be the state of <code>ds</code>, and <span>$y$</span> a deviation (or perturbation) vector. These two are evolved in parallel according to</p><p class="math-container">\[\begin{array}{rcl}
\frac{d\vec{x}}{dt} &amp;=&amp; f(\vec{x}) \\
\frac{dY}{dt} &amp;=&amp; J_f(\vec{x}) \cdot Y
\end{array}
\quad \mathrm{or}\quad
\begin{array}{rcl}
\vec{x}_{n+1} &amp;=&amp; f(\vec{x}_n) \\
Y_{n+1} &amp;=&amp; J_f(\vec{x}_n) \cdot Y_n.
\end{array}\]</p><p>for continuous or discrete time respectively. Here <span>$f$</span> is the <a href="@ref"><code>dynamic_rule</code></a><code>(ds)</code> and <span>$J_f$</span> is the Jacobian of <span>$f$</span>.</p><p><strong>Jacobian</strong></p><p>The keyword <code>J</code> provides the Jacobian function. It must be a Julia function in the same form as <code>f</code>, the <a href="@ref"><code>dynamic_rule</code></a>. Specifically, <code>J(u, p, n) -&gt; M::SMatrix</code> for the out-of-place version or <code>J(M, u, p, n)</code> for the in-place version acting in-place on <code>M</code>. in both cases <code>M</code> is a matrix whose columns are the deviation vectors.</p><p>By default <code>J = nothing</code>.  In this case <code>J</code> is constructed automatically using the module <a href="https://github.com/JuliaDiff/ForwardDiff.jl"><code>ForwardDiff</code></a>, hence its limitations also apply here. Even though <code>ForwardDiff</code> is very fast, depending on your exact system you might gain significant speed-up by providing a hand-coded Jacobian and so it is recommended. Additionally, automatic and in-place Jacobians cannot be time dependent.</p><p>The keyword <code>J0</code> allows you to pass an initialized Jacobian matrix <code>J0</code>. This is useful for large in-place systems where only a few components of the Jacobian change during the time evolution. <code>J0</code> can be a sparse or any other matrix type. If not given, a matrix of zeros is used. <code>J0</code> is ignored for out of place systems.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.ParallelDynamicalSystem" href="#DynamicalSystemsBase.ParallelDynamicalSystem"><code>DynamicalSystemsBase.ParallelDynamicalSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParallelDynamicalSystem &lt;: DynamicalSystem
ParallelDynamicalSystem(ds::DynamicalSystem, states::Vector{&lt;:AbstractArray})</code></pre><p>A struct that evolves several <code>states</code> of a given dynamical system in parallel <strong>at exactly the same times</strong>. Useful when wanting to evolve several different trajectories of the same system while ensuring that they share parameters and time vector.</p><p>This struct follows the <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a> interface with the following adjustments:</p><ul><li>The function <a href="@ref"><code>current_state</code></a> is called as <code>current_state(pds, i::Int = 1)</code> which returns the <code>i</code>th state. Same for <a href="@ref"><code>initial_state</code></a>.</li><li>Similarly, <a href="@ref"><code>set_state!</code></a> obtains a second argument <code>i::Int = 1</code> to set the <code>i</code>-th state.</li><li><a href="@ref"><code>current_states</code></a> and <a href="@ref"><code>initial_states</code></a> can be used to get all parallel states.</li><li><a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a> takes in a vector of states (like <code>states</code>) for <code>u</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.ProjectedDynamicalSystem" href="#DynamicalSystemsBase.ProjectedDynamicalSystem"><code>DynamicalSystemsBase.ProjectedDynamicalSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProjectedDynamicalSystem &lt;: DynamicalSystem
ProjectedDynamicalSystem(ds::DynamicalSystem, projection, complete_state)</code></pre><p>A dynamical system that represents a projection of an existing <code>ds</code> on a (projected) space.</p><p>The <code>projection</code> defines the projected space. If <code>projection isa AbstractVector{Int}</code>, then the projected space is simply the variable indices that <code>projection</code> contains. Otherwise, <code>projection</code> can be an arbitrary function that given the state of the original system <code>ds</code>, returns the state in the projected space. In this case the projected space can be equal, or even higher-dimensional, than the original.</p><p><code>complete_state</code> produces the state for the original system from the projected state. <code>complete_state</code> can always be a function that given the projected state returns a state in the original space. However, if <code>projection isa AbstractVector{Int}</code>, then <code>complete_state</code> can also be a vector that contains the values of the <em>remaining</em> variables of the system, i.e., those <em>not</em> contained in the projected space. In this case the projected space needs to be lower-dimensional than the original.</p><p>Notice that <code>ProjectedDynamicalSystem</code> does not require an invertible projection, <code>complete_state</code> is only used during <a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a>. <code>ProjectedDynamicalSystem</code> is in fact a rather trivial wrapper of <code>ds</code> which steps it as normal in the original state space and only projects as a last step, e.g., during <a href="@ref"><code>current_state</code></a>.</p><p><strong>Examples</strong></p><p>Case 1: project 5-dimensional system to its last two dimensions.</p><pre><code class="language-julia hljs">ds = Systems.lorenz96(5)
projection = [4, 5]
complete_state = [0.0, 0.0, 0.0] # completed state just in the plane of last two dimensions
pds = projected_integrator(ds, projection, complete_state)
reinit!(pds, [0.2, 0.4])
step!(pds)
get_state(pds)</code></pre><p>Case 2: custom projection to general functions of state. <code>julia ds = Systems.lorenz96(5) projection(u) = [sum(u), sqrt(u[1]^2 + u[2]^2)] complete_state(y) = repeat(y[1]/5, 5) pds = # same as in above example...</code>`</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}" href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>SciMLBase.reinit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reinit!(ds::DynamicalSystem, u = initial_state(ds); kwargs...) → ds</code></pre><p>Reset the status of <code>ds</code>, so that it is as if it has be just initialized with initial state <code>u</code>. Practically every function of the ecosystem that evolves <code>ds</code> first calls this function on it. Besides the new initial state <code>u</code>, you can also configure the keywords <code>t0 = initial_time(ds)</code> and <code>p = current_parameters(ds)</code>.</p><p>Note the default settings: the state and time are the initial, but the parameters are the current.</p><p>The special method <code>reinit!(ds, ::Nothing; kwargs...)</code> is also available, which does nothing and leaves the system as is. This is so that downstream functions that call <code>reinit!</code> can still be used without resetting the system but rather continuing from its exact current state.</p></div></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-DatserisParlitz2022"><a class="tag is-link" href="#citeref-DatserisParlitz2022">DatserisParlitz2022</a>Datseris &amp; Parlitz 2022, <em>Nonlinear Dynamics: A Concise Introduction Interlaced with Code</em>, <a href="https://doi.org/10.1007/978-3-030-91032-7">Springer Nature, Undergrad. Lect. Notes In Physics</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="orbitdiagram/">Orbit diagrams »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 25 February 2023 19:52">Saturday 25 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
